<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LINE OA å½ˆçª—ç†±å€ç·¨è¼¯å™¨ï¼ˆCanva ç‰ˆï½œè£åˆ‡æ‹–ç§»ï¼‹Undo/Redoï¼‹æª”åï¼‰</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://static.line-scdn.net/liff/edge/2/sdk.js"></script>

  <style>
    .workbench{
      background:
        linear-gradient(#f3f4f6 1px, transparent 1px) 0 0/24px 24px,
        linear-gradient(90deg, #f3f4f6 1px, transparent 1px) 0 0/24px 24px,
        #eef2f7;
    }

    /* stage transform */
    #stage{ position:relative; transform-origin: top left; }
    #drawLayer{ position:absolute; inset:0; }

    /* hotspots */
    .area-box{
      position:absolute;
      border:2px solid rgba(255,0,0,.9);
      background:rgba(255,0,0,.12);
      color:white;
      font-weight:900;
      display:flex;
      justify-content:center;
      align-items:center;
      user-select:none;
      text-shadow:0 1px 2px rgba(0,0,0,.9);
      box-sizing:border-box;
      cursor:move;
    }
    .area-box.selected{
      outline: 2px solid rgba(59,130,246,.95);
      box-shadow: 0 0 0 4px rgba(59,130,246,.18);
    }

    .handle{
      position:absolute;
      width:10px; height:10px;
      background:white;
      border:2px solid rgba(59,130,246,.95);
      border-radius:2px;
      box-sizing:border-box;
    }
    .handle.nw{ left:-6px; top:-6px; cursor:nwse-resize; }
    .handle.n { left:calc(50% - 5px); top:-6px; cursor:ns-resize; }
    .handle.ne{ right:-6px; top:-6px; cursor:nesw-resize; }
    .handle.e { right:-6px; top:calc(50% - 5px); cursor:ew-resize; }
    .handle.se{ right:-6px; bottom:-6px; cursor:nwse-resize; }
    .handle.s { left:calc(50% - 5px); bottom:-6px; cursor:ns-resize; }
    .handle.sw{ left:-6px; bottom:-6px; cursor:nesw-resize; }
    .handle.w { left:-6px; top:calc(50% - 5px); cursor:ew-resize; }

    .draw-rect{
      position:absolute;
      border:2px dashed rgba(0,0,0,.55);
      background:rgba(0,0,0,.08);
      pointer-events:none;
      box-sizing:border-box;
    }

    /* space panning */
    .panning { cursor: grab !important; }
    .panning:active { cursor: grabbing !important; }

    /* left collapse */
    .sidebar-collapsed{ width:56px !important; min-width:56px !important; max-width:56px !important; }
    .sidebar-collapsed .sidebar-hide{ display:none !important; }

    /* line frame overlay */
    .line-frame{
      position:absolute;
      inset:-14px;
      border:2px solid rgba(15,23,42,.55);
      border-radius:14px;
      pointer-events:none;
    }
    .line-frame .tag{
      position:absolute;
      top:-12px; left:10px;
      font-size:11px;
      background:rgba(15,23,42,.85);
      color:white;
      padding:3px 8px;
      border-radius:999px;
      letter-spacing:.2px;
    }

    /* crop frame + image drag */
    .crop-wrap{
      position:relative;
      overflow:hidden;
      border-radius:10px;
      background:#fff;
      box-shadow: 0 8px 24px rgba(0,0,0,.08);
    }
    .crop-img{
      position:absolute;
      left:0; top:0;
      will-change: transform;
      cursor:grab;
      user-select:none;
      -webkit-user-drag:none;
    }
    .crop-img:active{ cursor:grabbing; }

    /* preview drawer hotspots */
    .preview-hotspot{
      position:absolute;
      border:2px solid rgba(255,0,0,.85);
      background:rgba(255,0,0,.10);
      pointer-events:none;
    }
  </style>
</head>

<body class="bg-slate-100 min-h-screen text-slate-800">

  <!-- Top bar -->
  <div class="bg-white shadow sticky top-0 z-30">
    <div class="px-4 py-3 flex items-center justify-between gap-3">
      <div class="flex items-center gap-3">
        <div class="font-black text-blue-700 text-lg">LINE OA å½ˆçª—ç†±å€ç·¨è¼¯å™¨ï¼ˆCanva ç‰ˆï¼‰</div>
        <div class="hidden md:block text-xs text-slate-500">
          ç©ºç™½éµæ‹–æ›³å¹³ç§»ï½œCtrl/Alt/Shift + æ»¾è¼ªç¸®æ”¾ï½œCtrl+Z/Ctrl+Y Undo/Redo
        </div>
      </div>
      <div class="flex gap-2">
        <button class="px-3 py-2 rounded bg-slate-900 text-white text-sm hover:bg-black"
          onclick="togglePreviewDrawer(true)">ğŸ“±é è¦½</button>
        <button class="px-3 py-2 rounded bg-slate-700 text-white text-sm hover:bg-slate-900"
          onclick="closeLiff()">é—œé–‰</button>
      </div>
    </div>

    <div class="px-4 pb-3 grid grid-cols-1 md:grid-cols-[1fr_1fr] gap-2">
      <input id="workerUrl" class="border rounded px-3 py-2 bg-yellow-50 text-sm"
        placeholder="Worker URLï¼ˆhttps://xxx.workers.devï¼‰" />
      <input id="triggerKeyword" class="border rounded px-3 py-2 text-sm font-bold border-blue-500"
        placeholder="è§¸ç™¼é—œéµå­—ï¼ˆä½¿ç”¨è€…è¼¸å…¥é€™å¥æœƒå‡ºç¾é€™å¼µåœ–ï¼‰" />
    </div>
  </div>

  <!-- Main -->
  <div class="p-4 pb-28" style="height:calc(100vh - 132px);">
    <div class="bg-white rounded-2xl shadow overflow-hidden h-full">
      <div class="flex h-full">

        <!-- Sidebar -->
        <div id="sidebar" class="w-[400px] min-w-[280px] max-w-[600px] border-r bg-white overflow-auto">
          <div class="p-3 border-b flex items-center justify-between">
            <div class="flex items-center gap-2">
              <button id="collapseBtn" class="w-10 h-10 rounded-xl bg-slate-900 text-white hover:bg-black font-black">â˜°</button>
              <div class="sidebar-hide">
                <div class="font-bold text-slate-700">å·¥å…·åˆ—</div>
                <div class="text-[11px] text-slate-500">å¯æ”¶åˆï½œè£åˆ‡æ‹–ç§»ï½œUndo/Redoï½œæª”å</div>
              </div>
            </div>
            <div class="sidebar-hide text-[11px] text-slate-500" id="status">ç‹€æ…‹ï¼šæœªåˆå§‹åŒ–</div>
          </div>

          <div class="p-3 space-y-3 sidebar-hide">

            <!-- File meta -->
            <div class="rounded-xl border bg-white p-3">
              <div class="text-xs font-bold text-slate-700 mb-2">ğŸ“ æª”æ¡ˆè³‡è¨Šï¼ˆç”¨ä¾†ç¯©é¸/å†ç·¨è¼¯ï¼‰</div>
              <label class="text-xs text-slate-600">
                æª”æ¡ˆåç¨±
                <input id="fileName" class="mt-1 w-full border rounded-lg px-3 py-2 text-sm font-bold"
                  placeholder="ä¾‹å¦‚ï¼š2026-02-é£²é£Ÿèœå–®_å½ˆçª—ç†±å€" />
              </label>
              <div class="mt-2 text-[11px] text-slate-500">
                æœƒå­˜åˆ° payload.meta.nameï¼Œä¹‹å¾Œ lab_dashboard å¯ä»¥ç”¨å®ƒç¯©é¸ã€‚
              </div>
            </div>

            <!-- LIFF info -->
            <div class="rounded-xl border bg-slate-50 p-3">
              <div class="text-xs font-bold text-slate-700 mb-2">LIFF / ä½¿ç”¨è€…</div>
              <div class="text-xs text-slate-600 space-y-1">
                <div>LIFFï¼š<span id="liffState" class="font-bold">-</span></div>
                <div>ä½¿ç”¨è€…ï¼š<span id="userName" class="font-bold">-</span></div>
              </div>
            </div>

            <!-- Crop mode -->
            <div class="rounded-xl border bg-white p-3">
              <div class="text-xs font-bold text-slate-700 mb-2">ğŸ–¼ï¸ LINE åº•æ¡† / è£åˆ‡æ‹–ç§»</div>
              <div class="grid grid-cols-2 gap-2 text-xs">
                <label class="flex items-center gap-2 col-span-2">
                  <input id="cropEnabled" type="checkbox" class="scale-110">
                  <span class="text-slate-700 font-bold">å•Ÿç”¨è£åˆ‡æ¨¡å¼ï¼ˆåœ–ç‰‡è¶…éåº•æ¡†å¯æ‹–ç§»ï¼‰</span>
                </label>

                <label class="flex flex-col gap-1">
                  <span class="text-slate-500">åº•æ¡†é•·é‚Šä¸Šé™</span>
                  <select id="maxSide" class="border rounded-lg px-2 py-2">
                    <option value="960">960</option>
                    <option value="1280" selected>1280ï¼ˆLINE å»ºè­°ï¼‰</option>
                    <option value="1600">1600</option>
                  </select>
                </label>

                <label class="flex flex-col gap-1">
                  <span class="text-slate-500">åº•æ¡†æ¯”ä¾‹</span>
                  <select id="frameAspect" class="border rounded-lg px-2 py-2">
                    <option value="square" selected>1:1 æ­£æ–¹å½¢ï¼ˆæœ€å¸¸ç”¨ï¼‰</option>
                    <option value="orig">è·ŸåŸåœ–æ¯”ä¾‹ï¼ˆåªç¸®æ”¾ä¸è£åˆ‡ï¼‰</option>
                    <option value="16:9">16:9ï¼ˆæ©«å¹…ï¼‰</option>
                    <option value="4:5">4:5ï¼ˆè²¼æ–‡å¸¸ç”¨ï¼‰</option>
                  </select>
                </label>

                <label class="flex flex-col gap-1 col-span-2">
                  <span class="text-slate-500">è£åˆ‡è¼¸å‡ºæç¤º</span>
                  <div class="text-[11px] text-slate-600 bg-slate-50 border rounded-lg p-2">
                    é–‹å•Ÿå¾Œï¼Œå³å´æœƒå‡ºç¾ã€ŒLINE åº•æ¡†ã€ï¼Œä½ å¯ä»¥ç›´æ¥æ‹–åœ–ç‰‡æ±ºå®šè£åˆ‡ä½ç½®ã€‚<br>
                    å„²å­˜æ™‚æœƒå…ˆç”¢ç”Ÿè£åˆ‡å¾Œçš„æ–°åœ–ï¼ˆä¸éœ€è¦ä½ è‡ªå·±è£ï¼‰ã€‚
                  </div>
                </label>

                <button class="col-span-2 text-xs px-3 py-2 rounded-lg bg-white border hover:bg-slate-50 font-bold"
                  onclick="resetCrop()">é‡ç½®è£åˆ‡ä½ç½®</button>
              </div>

              <div class="mt-3 rounded-lg bg-slate-50 border p-2 text-[11px] text-slate-700">
                <div class="font-bold mb-1">å°ºå¯¸æª¢æŸ¥</div>
                <div id="sizeInfo" class="text-slate-600">å°šæœªè¼‰å…¥åœ–ç‰‡</div>
              </div>
            </div>

            <!-- Compress -->
            <div class="rounded-xl border bg-white p-3">
              <div class="text-xs font-bold text-slate-700 mb-2">ğŸ§© ä¸Šå‚³å£“ç¸®</div>
              <div class="grid grid-cols-2 gap-2 text-xs">
                <label class="flex flex-col gap-1">
                  <span class="text-slate-500">æ ¼å¼</span>
                  <select id="outFormat" class="border rounded-lg px-2 py-2">
                    <option value="image/webp" selected>WebPï¼ˆæ¨è–¦ï¼‰</option>
                    <option value="image/jpeg">JPEG</option>
                  </select>
                </label>

                <label class="flex items-center gap-2 col-span-1">
                  <input id="cropSquareUpload" type="checkbox" class="scale-110">
                  <span class="text-slate-600">ä¸Šå‚³å…ˆè£åˆ‡æ­£æ–¹å½¢</span>
                </label>

                <label class="flex flex-col gap-1 col-span-2">
                  <span class="text-slate-500">å“è³ª <span id="qVal">0.82</span></span>
                  <input id="quality" type="range" min="0.55" max="0.95" step="0.01" value="0.82">
                </label>
              </div>
            </div>

            <!-- Zoom -->
            <div class="rounded-xl border bg-white p-3">
              <div class="text-xs font-bold text-slate-700 mb-2">ğŸ” ç¸®æ”¾ / è¦–åœ–</div>
              <div class="flex items-center gap-2">
                <button class="text-xs bg-slate-900 text-white px-3 py-2 rounded-lg hover:bg-black font-bold"
                  onclick="zoomBy(-0.1)">-</button>
                <input id="zoomRange" type="range" min="0.3" max="4" step="0.01" value="1" class="w-full">
                <button class="text-xs bg-slate-900 text-white px-3 py-2 rounded-lg hover:bg-black font-bold"
                  onclick="zoomBy(0.1)">+</button>
                <div class="text-xs font-black w-14 text-right" id="zoomLabel">100%</div>
              </div>
              <div class="mt-2 grid grid-cols-3 gap-2">
                <button class="text-xs bg-white border px-3 py-2 rounded-lg hover:bg-slate-50 font-bold"
                  onclick="setZoom(1)">100%</button>
                <button class="text-xs bg-white border px-3 py-2 rounded-lg hover:bg-slate-50 font-bold"
                  onclick="fitToView()">Fit</button>
                <button class="text-xs bg-white border px-3 py-2 rounded-lg hover:bg-slate-50 font-bold"
                  onclick="centerView()">ç½®ä¸­</button>
              </div>
              <div class="mt-2 text-[11px] text-slate-500">
                å¹³ç§»ï¼šæŒ‰ä½ <b>ç©ºç™½éµ</b> + æ‹–æ›³ï½œç¸®æ”¾ï¼š<b>Ctrl/Alt/Shift</b> + æ»¾è¼ª
              </div>
            </div>

            <!-- Actions -->
            <div class="rounded-xl border bg-white p-3">
              <div class="text-xs font-bold text-slate-700 mb-2">âš™ï¸ æ“ä½œ</div>
              <div class="grid grid-cols-2 gap-2">
                <button class="px-3 py-2 rounded-lg bg-blue-600 text-white text-sm hover:bg-blue-700 font-bold"
                  onclick="pickAndUpload()">ä¸Šå‚³åˆ° R2</button>
                <button class="px-3 py-2 rounded-lg bg-gray-600 text-white text-sm hover:bg-gray-700 font-bold"
                  onclick="loadConfig()">è®€å–</button>
                <button class="px-3 py-2 rounded-lg bg-green-600 text-white text-sm hover:bg-green-700 font-bold"
                  onclick="saveConfig()">å„²å­˜</button>
                <button class="px-3 py-2 rounded-lg bg-red-600 text-white text-sm hover:bg-red-700 font-bold"
                  onclick="clearAreas()">æ¸…ç©ºæ¡†</button>
              </div>
              <button class="mt-2 w-full px-3 py-2 rounded-lg bg-black text-white text-sm hover:bg-slate-900 font-bold"
                onclick="sendTestToMe()">é€åˆ°æˆ‘æ¸¬è©¦</button>

              <div class="mt-2 text-[11px] text-slate-500">
                Undoï¼šCtrl+Zï½œRedoï¼šCtrl+Y æˆ– Ctrl+Shift+Z
              </div>
            </div>

            <!-- Areas -->
            <div class="rounded-xl border bg-white p-3">
              <div class="flex items-center justify-between mb-2">
                <div class="text-xs font-bold text-slate-700">ğŸŸ¥ æ¡†æ¡†è¨­å®š</div>
                <div class="text-[11px] text-slate-500">Delete å¯åˆªé¸å–æ¡†</div>
              </div>
              <div class="text-[11px] text-slate-500 mb-3">
                æ¯å€‹æ¡†çš„ã€Œå…§å®¹ã€ï¼é»åˆ°æ™‚é€å‡ºçš„æ–‡å­—ï¼ˆè§¸ç™¼ä½ çš„è‡ªå‹•å›è¦†ï¼‰
              </div>
              <div id="areaList" class="space-y-2"></div>
              <div id="areaEmpty" class="text-xs text-slate-400">ç›®å‰æ²’æœ‰æ¡†ï¼Œå»å³é‚Šåœ–ç‰‡ä¸Šæ‹–æ›³ç•«æ¡†ã€‚</div>
            </div>
          </div>
        </div>

        <!-- Canvas -->
        <div class="flex-1 flex flex-col">
          <div class="px-4 py-2 bg-slate-50 border-b text-xs text-slate-700 flex items-center justify-between">
            <div>æ‹–æ›³æ–°å¢æ¡†ï½œé¸å–æ¡†å¯æ‹–ç§»/æ‹‰è§’ç¸®æ”¾ï½œè£åˆ‡æ¨¡å¼ï¼šæ‹–åœ–ç‰‡æ±ºå®šè£åˆ‡ä½ç½®</div>
            <div class="flex items-center gap-2">
              <button class="text-[11px] px-3 py-1.5 rounded-lg bg-white border hover:bg-slate-50 font-bold"
                onclick="setZoom(1)">100%</button>
              <button class="text-[11px] px-3 py-1.5 rounded-lg bg-white border hover:bg-slate-50 font-bold"
                onclick="fitToView()">Fit</button>
            </div>
          </div>

          <div id="canvasWrap" class="relative flex-1 overflow-auto workbench">
            <div class="min-w-full min-h-full flex items-center justify-center p-10">
              <div id="stage" class="relative inline-block">

                <!-- crop frame (only when enabled) -->
                <div id="cropFrame" class="crop-wrap hidden">
                  <img id="cropImg" class="crop-img" alt="">
                  <div id="cropLayer" class="absolute inset-0"></div>
                  <div class="line-frame">
                    <div class="tag" id="lineFrameTag">LINE åº•æ¡†</div>
                  </div>
                </div>

                <!-- normal mode -->
                <div id="normalFrame" class="relative">
                  <div id="lineFrameNormal" class="line-frame hidden">
                    <div class="tag" id="lineFrameTagNormal">LINE å»ºè­°ç¯„åœ</div>
                  </div>
                  <img id="preview" class="block pointer-events-none select-none" style="max-width:none;" alt="">
                  <div id="drawLayer"></div>
                </div>

              </div>
            </div>
          </div>

          <div class="px-4 py-3 bg-gray-50 text-center text-xs text-gray-600">
            å³å´æ˜¯ Canva å·¥ä½œå€ã€‚è£åˆ‡æ¨¡å¼ä¸‹ï¼Œç†±å€åº§æ¨™ä»¥ã€Œåº•æ¡†ã€ç‚ºåŸºæº–ï¼ˆæœ€ç¬¦åˆä½ çš„éœ€æ±‚ï¼‰ã€‚
          </div>
        </div>

      </div>
    </div>
  </div>

  <input type="file" id="fileInput" accept="image/*" hidden>

  <!-- Preview Drawer -->
  <div id="drawerOverlay" class="fixed inset-0 bg-black/40 hidden z-40" onclick="togglePreviewDrawer(false)"></div>
  <div id="previewDrawer" class="fixed left-0 right-0 bottom-0 z-50 translate-y-full transition-transform duration-300 ease-out">
    <div class="mx-auto max-w-4xl">
      <div class="bg-white rounded-t-2xl shadow-2xl overflow-hidden">
        <div class="flex items-center justify-between px-4 py-3 border-b">
          <div class="font-bold text-slate-700">ğŸ“± æ‰‹æ©Ÿå½ˆçª—é è¦½ï¼ˆå¯æ”¶æ”¾ï¼‰</div>
          <div class="flex items-center gap-2">
            <label class="flex items-center gap-2 text-xs text-slate-600">
              <input id="showHotspots" type="checkbox" checked>
              é¡¯ç¤ºç†±å€æ¡†
            </label>
            <button class="px-3 py-1.5 rounded bg-slate-200 text-slate-700 text-sm hover:bg-slate-300"
              onclick="togglePreviewDrawer(false)">æ”¶èµ·</button>
          </div>
        </div>

        <div class="p-4 bg-slate-50">
          <div class="mx-auto w-[360px] max-w-full">
            <div class="rounded-[26px] border-4 border-slate-900 bg-slate-900 p-2">
              <div class="rounded-[20px] bg-white overflow-hidden">
                <div class="bg-slate-100 text-xs text-slate-600 px-3 py-2 border-b flex items-center justify-between">
                  <span>LINE èŠå¤©å…§å°ºå¯¸æ„Ÿ</span>
                  <button class="text-[11px] px-2 py-1 rounded bg-white border hover:bg-slate-50"
                          onclick="sendPreviewToMe()">ç›´æ¥é€åˆ°æˆ‘æ¸¬è©¦</button>
                </div>

                <div class="p-3">
                  <div class="mx-auto w-[320px] max-w-full">
                    <div class="text-[11px] text-slate-500 mb-2">é»ç†±å€æœƒæç¤ºé€å‡ºçš„é—œéµå­—ï¼ˆæ¨¡æ“¬é»é¸ï¼‰</div>
                    <div class="relative rounded-lg overflow-hidden border bg-white">
                      <img id="phoneImg" class="w-full h-[220px] object-cover bg-gray-100" alt="">
                      <div id="phoneHotspots" class="absolute inset-0"></div>
                    </div>
                    <div class="mt-2 text-[11px] text-slate-500">* å¯¦éš›æœƒå› æ‰‹æ©Ÿç•¥æœ‰å·®ç•°</div>
                  </div>
                </div>
              </div>
            </div>

            <div class="mt-3 flex gap-2">
              <button class="flex-1 px-3 py-2 rounded bg-slate-900 text-white text-sm hover:bg-black"
                onclick="togglePreviewDrawer(false)">æ”¶èµ·é è¦½</button>
              <button class="flex-1 px-3 py-2 rounded bg-blue-600 text-white text-sm hover:bg-blue-700"
                onclick="refreshPhonePreview()">é‡æ–°æ¸²æŸ“</button>
            </div>
          </div>
        </div>

        <div class="px-4 py-3 bg-white border-t text-xs text-slate-500">
          æç¤ºï¼šä½ ç•«æ¡†/æ”¹æ–‡å­—/ç§»å‹•è£åˆ‡å¾Œï¼Œé è¦½æœƒè‡ªå‹•æ›´æ–°ã€‚
        </div>
      </div>
    </div>
  </div>

<script>
/* ===================== ä½ åªè¦æ”¹é€™è£¡ ===================== */
const LIFF_ID = "2009037126-AD8Dolxb";
/* ======================================================= */

const $ = (id) => document.getElementById(id);

let isReady = false;

// æ ¸å¿ƒè³‡æ–™ï¼šareas ä»¥ã€Œç·¨è¼¯åº§æ¨™ç³»ã€0~1 å­˜ï¼ˆè£åˆ‡æ¨¡å¼æ™‚=åº•æ¡†åº§æ¨™ç³»ï¼›éè£åˆ‡æ¨¡å¼æ™‚=åŸåœ–åº§æ¨™ç³»ï¼‰
let state = {
  imageUrl: "",
  areas: [],          // [{x,y,w,h,text}]
  crop: {             // è£åˆ‡æ¨¡å¼ç‹€æ…‹ï¼ˆåº•æ¡†è¦–çª—ï¼‰
    enabled: false,
    frameW: 1280,
    frameH: 1280,
    scale: 1,         // cover scale applied to original image
    tx: 0,            // translate (px) of image inside frame
    ty: 0
  },
  meta: { name: "" }
};

let ZOOM = 1;
let selectedIndex = -1;

/* ------------------- Undo/Redo ------------------- */
let history = [];
let historyIndex = -1;
let historyLock = false;

function cloneDeep(obj){ return JSON.parse(JSON.stringify(obj)); }

function pushHistory(reason=""){
  if(historyLock) return;
  const snap = cloneDeep({ state, selectedIndex });
  if(historyIndex >= 0){
    const prev = history[historyIndex];
    // é¿å…é€£çºŒå®Œå…¨ç›¸åŒ
    if(JSON.stringify(prev) === JSON.stringify(snap)) return;
  }
  history = history.slice(0, historyIndex + 1);
  history.push(snap);
  historyIndex = history.length - 1;
}

function applyHistorySnap(snap){
  historyLock = true;
  state = cloneDeep(snap.state);
  selectedIndex = snap.selectedIndex;

  $("fileName").value = state.meta?.name || "";
  $("cropEnabled").checked = !!state.crop?.enabled;

  // render view
  if(state.imageUrl){
    if(state.crop.enabled){
      enterCropMode(true);
      $("cropImg").src = state.imageUrl;
    }else{
      exitCropMode(true);
      $("preview").src = state.imageUrl;
    }
  }else{
    exitCropMode(true);
    $("preview").src = "";
    $("cropImg").src = "";
  }

  renderAreas();
  renderAreaList();
  refreshPhonePreview();
  updateSizeInfo();

  historyLock = false;
}

function undo(){
  if(historyIndex <= 0) return;
  historyIndex--;
  applyHistorySnap(history[historyIndex]);
}
function redo(){
  if(historyIndex >= history.length - 1) return;
  historyIndex++;
  applyHistorySnap(history[historyIndex]);
}

/* Key binds: Ctrl+Z / Ctrl+Y / Ctrl+Shift+Z */
window.addEventListener("keydown", (e) => {
  const isMac = /Mac|iPhone|iPad|iPod/i.test(navigator.platform);
  const mod = isMac ? e.metaKey : e.ctrlKey;

  if(mod && e.key.toLowerCase() === "z" && !e.shiftKey){
    e.preventDefault();
    undo();
  }
  if((mod && e.key.toLowerCase() === "y") || (mod && e.key.toLowerCase() === "z" && e.shiftKey)){
    e.preventDefault();
    redo();
  }
});

/* ------------------- Utils ------------------- */
function normalizeWorkerUrl(raw){
  if(!raw) return "";
  let s = raw.trim();
  if(!/^https?:\/\//i.test(s)) s = "https://" + s;
  return s.replace(/\/+$/,'');
}
function setStatus(msg){ $("status").textContent = "ç‹€æ…‹ï¼š" + msg; }
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
function clamp01(v){ return clamp(v,0,1); }

async function postJSON(url, data){
  const res = await fetch(url, {
    method:"POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify(data)
  });
  if(!res.ok){
    const t = await res.text().catch(()=> "");
    throw new Error(`HTTP ${res.status}\n${t}`);
  }
  const ct = res.headers.get("content-type") || "";
  return ct.includes("json") ? res.json() : res.text();
}

async function uploadToR2(workerBaseUrl, fileBlob, filename){
  const form = new FormData();
  form.append("file", fileBlob, filename || "image.webp");
  const res = await fetch(workerBaseUrl + "/upload", { method:"POST", body: form });
  if(!res.ok){
    const t = await res.text().catch(()=> "");
    throw new Error(`HTTP ${res.status}\n${t}`);
  }
  const j = await res.json();
  if(!j.ok || !j.url) throw new Error("ä¸Šå‚³å›å‚³æ ¼å¼ä¸å°");
  return j.url;
}

/* ------------------- Sidebar collapse ------------------- */
const sidebar = $("sidebar");
let sidebarCollapsed = false;
$("collapseBtn").onclick = () => {
  sidebarCollapsed = !sidebarCollapsed;
  sidebar.classList.toggle("sidebar-collapsed", sidebarCollapsed);
  $("collapseBtn").textContent = sidebarCollapsed ? "â«¶" : "â˜°";
};

/* ------------------- Zoom & Pan ------------------- */
const stage = $("stage");
const canvasWrap = $("canvasWrap");
const zoomRange = $("zoomRange");
const zoomLabel = $("zoomLabel");

let spaceDown = false;
let panDown = false, panSX=0, panSY=0, panScrollL=0, panScrollT=0;

function applyZoom(){
  stage.style.transform = `scale(${ZOOM})`;
  zoomRange.value = String(ZOOM);
  zoomLabel.textContent = Math.round(ZOOM * 100) + "%";
}
function setZoom(v){
  ZOOM = clamp(Number(v)||1, 0.3, 4);
  applyZoom();
}
function zoomBy(delta){ setZoom((ZOOM + delta).toFixed(2)); }

zoomRange.addEventListener("input", () => setZoom(zoomRange.value));

canvasWrap.addEventListener("wheel", (e) => {
  if(!(e.ctrlKey || e.altKey || e.shiftKey)) return;
  e.preventDefault();
  zoomBy(e.deltaY > 0 ? -0.10 : 0.10);
}, { passive:false });

function centerView(){
  const el = state.crop.enabled ? $("cropFrame") : $("preview");
  const w = state.crop.enabled ? state.crop.frameW : (el.naturalWidth||0);
  const h = state.crop.enabled ? state.crop.frameH : (el.naturalHeight||0);
  if(!w || !h) return;

  const cw = canvasWrap.clientWidth;
  const ch = canvasWrap.clientHeight;
  const sw = w * ZOOM;
  const sh = h * ZOOM;
  canvasWrap.scrollLeft = Math.max(0, (sw - cw) / 2);
  canvasWrap.scrollTop  = Math.max(0, (sh - ch) / 2);
}

function fitToView(){
  const w = state.crop.enabled ? state.crop.frameW : ($("preview").naturalWidth||0);
  const h = state.crop.enabled ? state.crop.frameH : ($("preview").naturalHeight||0);
  if(!w || !h) return;

  const padding = 160;
  const vw = Math.max(200, canvasWrap.clientWidth - padding);
  const vh = Math.max(200, canvasWrap.clientHeight - padding);
  const z = Math.min(vw / w, vh / h);
  setZoom(z.toFixed(2));
  requestAnimationFrame(() => centerView());
}

function setPanningUI(on){ canvasWrap.classList.toggle("panning", on); }

window.addEventListener("keydown", (e) => {
  if(e.code === "Space" && !spaceDown){
    spaceDown = true;
    setPanningUI(true);
  }
  if(e.key === "Delete" || e.key === "Backspace"){
    if(selectedIndex >= 0){
      if(confirm(`åˆªé™¤æ¡† ${selectedIndex+1}ï¼Ÿ`)){
        state.areas.splice(selectedIndex,1);
        selectedIndex = -1;
        pushHistory("delete-area");
        renderAreas(); renderAreaList(); refreshPhonePreview();
      }
    }
  }
});
window.addEventListener("keyup", (e) => {
  if(e.code === "Space"){
    spaceDown = false;
    panDown = false;
    setPanningUI(false);
  }
});

canvasWrap.addEventListener("mousedown", (e) => {
  if(!spaceDown) return;
  panDown = true;
  panSX = e.clientX;
  panSY = e.clientY;
  panScrollL = canvasWrap.scrollLeft;
  panScrollT = canvasWrap.scrollTop;
  e.preventDefault();
});
window.addEventListener("mousemove", (e) => {
  if(!panDown) return;
  const dx = e.clientX - panSX;
  const dy = e.clientY - panSY;
  canvasWrap.scrollLeft = panScrollL - dx;
  canvasWrap.scrollTop  = panScrollT - dy;
});
window.addEventListener("mouseup", () => { panDown = false; });

/* ------------------- Upload compress ------------------- */
$("quality").addEventListener("input", () => $("qVal").textContent = $("quality").value);

async function compressImage(file, {maxSide, mime, quality, cropSquare}){
  const img = await createImageBitmap(file);
  let sx=0, sy=0, sw=img.width, sh=img.height;

  if(cropSquare){
    const side = Math.min(img.width, img.height);
    sx = Math.floor((img.width - side)/2);
    sy = Math.floor((img.height - side)/2);
    sw = side; sh = side;
  }

  const longSide = Math.max(sw, sh);
  const scale = Math.min(1, maxSide / longSide);
  const w = Math.max(1, Math.round(sw * scale));
  const h = Math.max(1, Math.round(sh * scale));

  const canvas = document.createElement("canvas");
  canvas.width = w; canvas.height = h;
  const ctx = canvas.getContext("2d", { alpha:true });
  ctx.drawImage(img, sx, sy, sw, sh, 0,0,w,h);

  const outBlob = await new Promise((resolve) => canvas.toBlob(resolve, mime, quality));
  if(!outBlob) throw new Error("å£“ç¸®å¤±æ•—ï¼ˆtoBlob ç©ºï¼‰");

  const ext = (mime === "image/webp") ? "webp" : "jpg";
  const safeName = (file.name || "image").replace(/\.[^/.]+$/, "");
  return { blob: outBlob, filename: `${safeName}.${ext}`, w, h };
}

/* ------------------- Crop mode logic ------------------- */
function getFrameSize(origW, origH){
  const maxSide = parseInt($("maxSide").value,10) || 1280;
  const aspect = $("frameAspect").value;

  if(aspect === "orig"){
    const long = Math.max(origW, origH);
    const scale = Math.min(1, maxSide / long);
    return { frameW: Math.round(origW * scale), frameH: Math.round(origH * scale) };
  }
  if(aspect === "16:9") return { frameW: maxSide, frameH: Math.round(maxSide * 9/16) };
  if(aspect === "4:5")  return { frameW: Math.round(maxSide * 4/5), frameH: maxSide };
  return { frameW: maxSide, frameH: maxSide }; // square
}

function enterCropMode(skipHistory=false){
  state.crop.enabled = true;
  $("cropFrame").classList.remove("hidden");
  $("normalFrame").classList.add("hidden");
  $("lineFrameNormal").classList.add("hidden");
  $("lineFrameTag").textContent = `LINE åº•æ¡†ï¼ˆè¼¸å‡ºï¼‰`;
  if(!skipHistory) pushHistory("crop-on");
}

function exitCropMode(skipHistory=false){
  state.crop.enabled = false;
  $("cropFrame").classList.add("hidden");
  $("normalFrame").classList.remove("hidden");
  if(!skipHistory) pushHistory("crop-off");
}

$("cropEnabled").addEventListener("change", () => {
  const on = $("cropEnabled").checked;
  if(!state.imageUrl){
    $("cropEnabled").checked = false;
    return alert("è«‹å…ˆä¸Šå‚³åœ–ç‰‡æˆ–è®€å–è³‡æ–™");
  }
  if(on){
    enterCropMode();
    setupCropFromImage(); // recalc
  }else{
    exitCropMode();
    // åˆ‡å›æ­£å¸¸æ¨¡å¼ï¼šåœ–ç‰‡é¡¯ç¤ºåŸåœ–ï¼ˆä¸æ”¹ URLï¼‰ï¼Œç†±å€ä»ä¿ç•™ï¼ˆåº§æ¨™ç³»ä¸åŒæ™‚ï¼Œå»ºè­°ä½ å›ºå®šç”¨è£åˆ‡æ¨¡å¼åšé€™é¡åŠŸèƒ½ï¼‰
    $("preview").src = state.imageUrl;
    renderAreas(); renderAreaList(); refreshPhonePreview();
  }
  fitToView();
});

$("frameAspect").addEventListener("change", () => {
  if(!state.imageUrl) return;
  if(state.crop.enabled){
    setupCropFromImage(true);
    pushHistory("crop-aspect");
    renderAreas(); renderAreaList(); refreshPhonePreview();
    fitToView();
  }else{
    updateSizeInfo();
  }
});

$("maxSide").addEventListener("change", () => {
  if(!state.imageUrl) return;
  if(state.crop.enabled){
    setupCropFromImage(true);
    pushHistory("crop-maxside");
    renderAreas(); renderAreaList(); refreshPhonePreview();
    fitToView();
  }
  updateSizeInfo();
});

function resetCrop(){
  if(!state.imageUrl || !state.crop.enabled) return;
  setupCropFromImage(true, true);
  pushHistory("crop-reset");
  renderAreas(); renderAreaList(); refreshPhonePreview();
}

async function setupCropFromImage(keepPosition=false, forceCenter=false){
  // load image to get natural size
  const img = new Image();
  img.crossOrigin = "anonymous";
  img.src = state.imageUrl;
  await img.decode().catch(()=>{});

  const origW = img.naturalWidth || 0;
  const origH = img.naturalHeight || 0;
  if(!origW || !origH) return;

  const { frameW, frameH } = getFrameSize(origW, origH);
  state.crop.frameW = frameW;
  state.crop.frameH = frameH;

  // compute cover scale for cropping modes (except orig which is just fit scale)
  let scale = 1;
  if($("frameAspect").value === "orig"){
    // no cropping, only scale down to fit frame
    scale = frameW / origW; // (same as frameH/origH)
  }else{
    scale = Math.max(frameW / origW, frameH / origH);
  }
  state.crop.scale = scale;

  // init translate so image centered in frame
  const imgW = origW * scale;
  const imgH = origH * scale;

  const minTX = frameW - imgW;
  const minTY = frameH - imgH;
  const maxTX = 0;
  const maxTY = 0;

  if(!keepPosition || forceCenter){
    state.crop.tx = Math.round((frameW - imgW)/2);
    state.crop.ty = Math.round((frameH - imgH)/2);
  }else{
    state.crop.tx = clamp(state.crop.tx, minTX, maxTX);
    state.crop.ty = clamp(state.crop.ty, minTY, maxTY);
  }

  // set DOM size
  const cropFrame = $("cropFrame");
  cropFrame.style.width = frameW + "px";
  cropFrame.style.height = frameH + "px";

  const cropImg = $("cropImg");
  cropImg.style.width = imgW + "px";
  cropImg.style.height = imgH + "px";
  cropImg.style.transform = `translate(${state.crop.tx}px, ${state.crop.ty}px)`;

  // layer coordinate system should match frame
  const cropLayer = $("cropLayer");
  cropLayer.style.width = frameW + "px";
  cropLayer.style.height = frameH + "px";

  updateSizeInfo(origW, origH);
}

/* drag image inside crop frame */
let cropDragging = false;
let cropStart = null;

$("cropImg").addEventListener("mousedown", (e) => {
  if(!state.crop.enabled) return;
  cropDragging = true;
  cropStart = { x: e.clientX, y: e.clientY, tx: state.crop.tx, ty: state.crop.ty };
  e.preventDefault();
});
window.addEventListener("mousemove", (e) => {
  if(!cropDragging || !cropStart) return;
  const dx = e.clientX - cropStart.x;
  const dy = e.clientY - cropStart.y;

  // bounds
  const frameW = state.crop.frameW;
  const frameH = state.crop.frameH;
  const imgEl = $("cropImg");
  const imgW = parseFloat(imgEl.style.width) || 0;
  const imgH = parseFloat(imgEl.style.height) || 0;

  const minTX = frameW - imgW;
  const minTY = frameH - imgH;
  const maxTX = 0;
  const maxTY = 0;

  state.crop.tx = clamp(cropStart.tx + dx, minTX, maxTX);
  state.crop.ty = clamp(cropStart.ty + dy, minTY, maxTY);

  imgEl.style.transform = `translate(${state.crop.tx}px, ${state.crop.ty}px)`;

  // ç†±å€æ˜¯ç•«åœ¨ cropLayer ä¸Šï¼Œä¸å—åœ–ç‰‡ç§»å‹•å½±éŸ¿ï¼ˆæ­£ç¢ºï¼‰
  refreshPhonePreview();
});
window.addEventListener("mouseup", () => {
  if(cropDragging){
    cropDragging = false;
    cropStart = null;
    pushHistory("crop-move");
  }
});

/* ------------------- Size info ------------------- */
function updateSizeInfo(origW=null, origH=null){
  const maxSide = parseInt($("maxSide").value,10) || 1280;

  // If known orig size
  if(origW && origH){
    const longSide = Math.max(origW, origH);
    const ok = longSide <= maxSide;
    $("sizeInfo").innerHTML = `
      åŸåœ–ï¼š<b>${origW}</b> Ã— <b>${origH}</b>ï¼ˆé•·é‚Šï¼š<b>${longSide}</b>ï¼‰<br>
      åº•æ¡†ä¸Šé™ï¼š<b>${maxSide}</b> â†’ ${ok ? `<span class="text-green-700 font-bold">OK</span>` : `<span class="text-red-700 font-black">è¶…éï¼ˆå»ºè­°é–‹è£åˆ‡æ¨¡å¼æˆ–é‡æ–°ä¸Šå‚³å£“ç¸®ï¼‰</span>`}
      ${state.crop.enabled ? `<br>è¼¸å‡ºåº•æ¡†ï¼š<b>${state.crop.frameW}</b> Ã— <b>${state.crop.frameH}</b>` : ""}
    `;
    return;
  }

  // fallback by DOM
  const img = state.crop.enabled ? $("cropImg") : $("preview");
  const w = state.crop.enabled ? state.crop.frameW : (img.naturalWidth||0);
  const h = state.crop.enabled ? state.crop.frameH : (img.naturalHeight||0);
  if(!w || !h){
    $("sizeInfo").textContent = "å°šæœªè¼‰å…¥åœ–ç‰‡";
    return;
  }
  const longSide = Math.max(w,h);
  const ok = longSide <= maxSide;
  $("sizeInfo").innerHTML = `
    ç›®å‰ï¼š<b>${w}</b> Ã— <b>${h}</b>ï¼ˆé•·é‚Šï¼š<b>${longSide}</b>ï¼‰<br>
    åº•æ¡†ä¸Šé™ï¼š<b>${maxSide}</b> â†’ ${ok ? `<span class="text-green-700 font-bold">OK</span>` : `<span class="text-red-700 font-black">è¶…é</span>`}
  `;
}

/* ------------------- Drawing hotspots (two layers) ------------------- */
const drawLayer = $("drawLayer");
const cropLayer = $("cropLayer");

function currentLayer(){
  return state.crop.enabled ? cropLayer : drawLayer;
}
function currentBaseSize(){
  if(state.crop.enabled){
    return { w: state.crop.frameW, h: state.crop.frameH };
  }
  const img = $("preview");
  return { w: img.naturalWidth||0, h: img.naturalHeight||0 };
}

function layerPoint(e){
  const layer = currentLayer();
  const rect = layer.getBoundingClientRect();
  // æ³¨æ„ï¼šlayer è·Ÿ stage ä¸€èµ·è¢« scale(ZOOM)ï¼Œæ‰€ä»¥è¦é™¤ä»¥ ZOOM å›åˆ°åº§æ¨™ç³»
  const x = (e.clientX - rect.left) / ZOOM;
  const y = (e.clientY - rect.top) / ZOOM;
  return { x, y, rect };
}
function toNormXY(x,y){
  const { w, h } = currentBaseSize();
  return { nx: x / w, ny: y / h };
}
function fromNormBox(a){
  const { w, h } = currentBaseSize();
  return { x: a.x*w, y: a.y*h, w: a.w*w, h: a.h*h };
}

/* draw new box */
let isDrawing = false;
let drawSX=0, drawSY=0;
let previewRect = null;

/* drag/resize box */
let dragMode = null;
let dragIndex = -1;
let dragStart = null;

function attachBoxHandles(boxEl, idx){
  ["nw","n","ne","e","se","s","sw","w"].forEach(key => {
    const h = document.createElement("div");
    h.className = "handle " + key;
    h.addEventListener("mousedown", (ev) => {
      if(spaceDown) return;
      ev.stopPropagation();
      dragMode = key;
      dragIndex = idx;
      const p = layerPoint(ev);
      dragStart = { px:p.x, py:p.y, base: cloneDeep(state.areas[idx]) };
    });
    boxEl.appendChild(h);
  });
}

function renderAreas(){
  const layer = currentLayer();
  layer.querySelectorAll(".area-box").forEach(el => el.remove());

  state.areas.forEach((a, i) => {
    const d = document.createElement("div");
    d.className = "area-box" + (i===selectedIndex ? " selected" : "");
    d.style.left = (a.x*100)+"%";
    d.style.top  = (a.y*100)+"%";
    d.style.width = (a.w*100)+"%";
    d.style.height= (a.h*100)+"%";
    d.textContent = (i+1);

    d.addEventListener("mousedown", (ev) => {
      if(spaceDown) return;
      ev.stopPropagation();
      selectedIndex = i;
      renderAreas(); renderAreaList(); refreshPhonePreview();

      dragMode = "move";
      dragIndex = i;
      const p = layerPoint(ev);
      dragStart = { px:p.x, py:p.y, base: cloneDeep(state.areas[i]) };
    });

    d.ondblclick = (ev) => {
      ev.stopPropagation();
      if(confirm(`åˆªé™¤æ¡† ${i+1}ï¼Ÿ`)){
        state.areas.splice(i,1);
        if(selectedIndex === i) selectedIndex = -1;
        pushHistory("delete-area");
        renderAreas(); renderAreaList(); refreshPhonePreview();
      }
    };

    if(i===selectedIndex) attachBoxHandles(d, i);
    layer.appendChild(d);
  });
}

/* draw handlers */
function bindLayerEvents(layerEl){
  layerEl.addEventListener("mousedown", (e) => {
    if(spaceDown) return;
    if(!state.imageUrl) return alert("è«‹å…ˆä¸Šå‚³åœ–ç‰‡æˆ–è®€å–è³‡æ–™");
    if(e.target !== layerEl) return;

    selectedIndex = -1;
    renderAreas(); renderAreaList(); refreshPhonePreview();

    const p = layerPoint(e);
    isDrawing = true;
    drawSX = p.x; drawSY = p.y;

    previewRect = document.createElement("div");
    previewRect.className = "draw-rect";
    previewRect.style.left = drawSX + "px";
    previewRect.style.top  = drawSY + "px";
    previewRect.style.width = "0px";
    previewRect.style.height= "0px";
    layerEl.appendChild(previewRect);
  });

  layerEl.addEventListener("mousemove", (e) => {
    if(isDrawing && previewRect){
      const p = layerPoint(e);
      const cx=p.x, cy=p.y;
      const x = Math.min(drawSX,cx);
      const y = Math.min(drawSY,cy);
      const w = Math.abs(cx-drawSX);
      const h = Math.abs(cy-drawSY);
      previewRect.style.left = x + "px";
      previewRect.style.top  = y + "px";
      previewRect.style.width = w + "px";
      previewRect.style.height= h + "px";
    }

    // drag/resize
    if(dragMode && dragIndex >= 0 && dragStart){
      const p = layerPoint(e);
      const dx = p.x - dragStart.px;
      const dy = p.y - dragStart.py;

      const basePx = fromNormBox(dragStart.base);
      let x=basePx.x, y=basePx.y, w=basePx.w, h=basePx.h;
      const minSize = 16;

      if(dragMode === "move"){
        x = basePx.x + dx;
        y = basePx.y + dy;
      }else{
        if(dragMode.includes("e")) w = Math.max(minSize, basePx.w + dx);
        if(dragMode.includes("s")) h = Math.max(minSize, basePx.h + dy);
        if(dragMode.includes("w")){ x = basePx.x + dx; w = Math.max(minSize, basePx.w - dx); }
        if(dragMode.includes("n")){ y = basePx.y + dy; h = Math.max(minSize, basePx.h - dy); }
      }

      const { w:BW, h:BH } = currentBaseSize();
      x = clamp(x, 0, BW - w);
      y = clamp(y, 0, BH - h);

      const a = state.areas[dragIndex];
      a.x = clamp01(x / BW);
      a.y = clamp01(y / BH);
      a.w = clamp01(w / BW);
      a.h = clamp01(h / BH);

      renderAreas();
      renderAreaList(false);
      refreshPhonePreview();
    }
  });
}
bindLayerEvents(drawLayer);
bindLayerEvents(cropLayer);

window.addEventListener("mouseup", (e) => {
  if(isDrawing){
    isDrawing = false;
    if(previewRect){ previewRect.remove(); previewRect=null; }

    const layerEl = currentLayer();
    const p = layerPoint(e);
    const ex=p.x, ey=p.y;

    const x = Math.min(drawSX, ex);
    const y = Math.min(drawSY, ey);
    const w = Math.abs(ex - drawSX);
    const h = Math.abs(ey - drawSY);
    if(w < 14 || h < 14) return;

    const { w:BW, h:BH } = currentBaseSize();
    const nx = x / BW, ny = y / BH;

    state.areas.push({ x:clamp01(nx), y:clamp01(ny), w:clamp01(w/BW), h:clamp01(h/BH), text:"" });
    selectedIndex = state.areas.length - 1;

    pushHistory("add-area");
    renderAreas(); renderAreaList(); refreshPhonePreview();
  }

  if(dragMode){
    dragMode = null; dragIndex = -1; dragStart = null;
    pushHistory("move/resize");
  }
});

/* ------------------- Area list ------------------- */
function escapeHtml(str){
  return String(str||"")
    .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
    .replaceAll('"',"&quot;").replaceAll("'","&#039;");
}

function renderAreaList(scrollToSelected=true){
  const list = $("areaList");
  list.innerHTML = "";
  $("areaEmpty").classList.toggle("hidden", state.areas.length !== 0);

  state.areas.forEach((a, i) => {
    const row = document.createElement("div");
    row.className = "border rounded-xl p-2 bg-white " + (i === selectedIndex ? "ring-2 ring-blue-400" : "");
    row.innerHTML = `
      <div class="flex items-center justify-between mb-2">
        <div class="font-bold text-sm">æ¡† ${i+1}</div>
        <button class="text-xs text-red-600 underline">åˆªé™¤</button>
      </div>
      <div class="text-xs text-slate-500 mb-1">é»æ­¤æ¡†é€å‡ºæ–‡å­—ï¼š</div>
      <input class="w-full border rounded-lg px-2 py-2 text-sm font-bold"
        placeholder="ä¾‹å¦‚ï¼šMENU_SHOP / MENU_CALENDAR / MENU_NUTRITION"
        value="${escapeHtml(a.text)}">
      <div class="mt-2 grid grid-cols-2 gap-2">
        <button class="text-xs px-3 py-2 rounded-lg bg-slate-900 text-white hover:bg-black font-bold">é¸å–</button>
        <button class="text-xs px-3 py-2 rounded-lg bg-white border hover:bg-slate-50 font-bold">å®šä½</button>
      </div>
    `;

    const del = row.querySelector("button.text-red-600");
    const input = row.querySelector("input");
    const pickBtn = row.querySelectorAll("button")[1];
    const focusBtn = row.querySelectorAll("button")[2];

    del.onclick = () => {
      if(confirm(`åˆªé™¤æ¡† ${i+1}ï¼Ÿ`)){
        state.areas.splice(i,1);
        if(selectedIndex === i) selectedIndex = -1;
        pushHistory("delete-area");
        renderAreas(); renderAreaList(); refreshPhonePreview();
      }
    };
    input.oninput = () => {
      a.text = input.value;
      pushHistory("edit-text");
      refreshPhonePreview();
    };

    pickBtn.onclick = () => {
      selectedIndex = i;
      renderAreas(); renderAreaList(); refreshPhonePreview();
    };
    focusBtn.onclick = () => {
      selectedIndex = i;
      renderAreas(); renderAreaList(false); refreshPhonePreview();
      focusArea(i);
    };

    list.appendChild(row);
    if(scrollToSelected && i === selectedIndex){
      setTimeout(() => row.scrollIntoView({ block:"nearest", behavior:"smooth" }), 10);
    }
  });
}

function focusArea(i){
  const a = state.areas[i];
  if(!a) return;
  const px = fromNormBox(a);
  const cx = (px.x + px.w/2) * ZOOM;
  const cy = (px.y + px.h/2) * ZOOM;
  canvasWrap.scrollLeft = Math.max(0, cx - canvasWrap.clientWidth/2);
  canvasWrap.scrollTop  = Math.max(0, cy - canvasWrap.clientHeight/2);
}

function clearAreas(){
  if(confirm("ç¢ºå®šæ¸…ç©ºå…¨éƒ¨æ¡†ï¼Ÿ")){
    state.areas = [];
    selectedIndex = -1;
    pushHistory("clear-areas");
    renderAreas(); renderAreaList(); refreshPhonePreview();
  }
}

/* ------------------- Pick & Upload ------------------- */
async function pickAndUpload(){
  const base = normalizeWorkerUrl($("workerUrl").value);
  if(!base) return alert("è«‹å…ˆå¡« Worker URL");
  localStorage.setItem("line_worker_url", base);

  const input = $("fileInput");
  input.value = "";
  input.onchange = async (e) => {
    const file = e.target.files[0];
    if(!file) return;

    setStatus("å£“ç¸®+ä¸Šå‚³ä¸­...");
    try{
      const maxSide = parseInt($("maxSide").value, 10) || 1280;
      const mime = $("outFormat").value;
      const quality = parseFloat($("quality").value);
      const cropSquare = $("cropSquareUpload").checked;

      const { blob, filename, w, h } = await compressImage(file, {maxSide, mime, quality, cropSquare});
      const url = await uploadToR2(base, blob, filename);

      state.imageUrl = url;
      state.areas = [];
      selectedIndex = -1;

      // keep meta name (optional)
      state.meta.name = ($("fileName").value || "").trim();

      // show according to crop mode toggle
      const wantCrop = $("cropEnabled").checked;
      if(wantCrop){
        enterCropMode(true);
        $("cropImg").src = url;
        await setupCropFromImage(false, true);
      }else{
        exitCropMode(true);
        $("preview").src = url;
        $("lineFrameNormal").classList.remove("hidden");
        $("lineFrameTagNormal").textContent = `LINE å»ºè­°ç¯„åœï¼ˆâ‰¤${maxSide}pxï¼‰`;
      }

      pushHistory("upload");
      renderAreas(); renderAreaList(); refreshPhonePreview();
      updateSizeInfo();
      setStatus("ä¸Šå‚³å®Œæˆ âœ…");
      togglePreviewDrawer(true);
      fitToView();
    }catch(err){
      setStatus("ä¸Šå‚³å¤±æ•—");
      alert("ä¸Šå‚³å¤±æ•—ï¼š\n" + err.message);
    }
  };
  input.click();
}

/* ------------------- Build imagemap message ------------------- */
async function buildImagemapMessage(){
  if(!state.imageUrl) throw new Error("å°šæœªä¸Šå‚³åœ–ç‰‡");
  if(state.areas.length === 0) throw new Error("å°šæœªç•«æ¡†");
  if(state.areas.some(a => !String(a.text||"").trim())) throw new Error("æœ‰æ¡†æ²’æœ‰å¡«å…§å®¹");

  // å¯¦éš›è¦é€å‡ºå»çš„åœ–ç‰‡ï¼šè£åˆ‡æ¨¡å¼ â†’ å…ˆå‰ç«¯ç”¢ç”Ÿè£åˆ‡å¾Œåœ–ç‰‡ä¸¦ä¸Šå‚³åˆ°R2ï¼Œå†ç”¨é‚£å¼µåœ–çš„URL
  let finalUrl = state.imageUrl;
  if(state.crop.enabled && $("frameAspect").value !== "orig"){
    finalUrl = await exportCroppedAndUpload();
  }

  // ä»¥ã€Œé¡¯ç¤ºåº§æ¨™ç³»ã€ç”¢å‡º actions
  const baseW = 1040;
  const baseH = await calcBaseH(finalUrl, baseW);

  const actions = state.areas.map(a => ({
    type: "message",
    text: a.text,
    area: {
      x: Math.round(a.x * baseW),
      y: Math.round(a.y * baseH),
      width: Math.round(a.w * baseW),
      height: Math.round(a.h * baseH)
    }
  }));

  return {
    type: "imagemap",
    baseUrl: finalUrl,
    altText: "è«‹é»é¸",
    baseSize: { width: baseW, height: baseH },
    actions
  };
}

async function calcBaseH(url, baseW){
  return new Promise((resolve) => {
    const im = new Image();
    im.crossOrigin = "anonymous";
    im.onload = () => {
      const ratio = im.naturalHeight / im.naturalWidth;
      const h = Math.max(1040, Math.round(baseW * ratio));
      resolve(h);
    };
    im.onerror = () => resolve(1040);
    im.src = url;
  });
}

/* ---- Export cropped image (only in crop mode) ---- */
async function exportCroppedAndUpload(){
  const base = normalizeWorkerUrl($("workerUrl").value);
  if(!base) throw new Error("è«‹å…ˆå¡« Worker URLï¼ˆè£åˆ‡è¼¸å‡ºéœ€è¦ä¸Šå‚³åˆ° R2ï¼‰");

  // load original image
  const im = new Image();
  im.crossOrigin = "anonymous";
  im.src = state.imageUrl;
  await im.decode().catch(()=>{});
  const origW = im.naturalWidth, origH = im.naturalHeight;
  if(!origW || !origH) throw new Error("è£åˆ‡å¤±æ•—ï¼šè®€ä¸åˆ°åŸåœ–å°ºå¯¸");

  // frame
  const frameW = state.crop.frameW;
  const frameH = state.crop.frameH;

  // cover scale used in crop
  const scale = state.crop.scale;
  const imgW = origW * scale;
  const imgH = origH * scale;

  // cropImg translate in frame: tx, ty
  const tx = state.crop.tx;
  const ty = state.crop.ty;

  // draw onto canvas of frame size
  const canvas = document.createElement("canvas");
  canvas.width = frameW;
  canvas.height = frameH;
  const ctx = canvas.getContext("2d");

  // Draw the scaled image with translate
  ctx.drawImage(im, tx, ty, imgW, imgH);

  const mime = $("outFormat").value;
  const quality = parseFloat($("quality").value);

  const blob = await new Promise((resolve) => canvas.toBlob(resolve, mime, quality));
  if(!blob) throw new Error("è£åˆ‡è¼¸å‡ºå¤±æ•—ï¼štoBlob ç©º");

  // filename
  const name = (state.meta?.name || "imagemap").trim().replace(/[\\/:*?"<>|]/g, "_");
  const ext = (mime === "image/webp") ? "webp" : "jpg";
  const filename = `${name || "imagemap"}_crop.${ext}`;

  // upload
  const url = await uploadToR2(base, blob, filename);
  return url;
}

/* ------------------- Save/Load with meta.name ------------------- */
async function saveConfig(){
  const base = normalizeWorkerUrl($("workerUrl").value);
  const keyword = $("triggerKeyword").value.trim();
  if(!base || !keyword) return alert("è«‹å¡« Worker URL + è§¸ç™¼é—œéµå­—");
  localStorage.setItem("line_worker_url", base);

  // update meta
  state.meta.name = ($("fileName").value || "").trim();

  try{
    const msg = await buildImagemapMessage();
    const payload = {
      mode:"imagemap",
      messages:[msg],
      meta: {
        name: state.meta.name || "",
        updatedAt: new Date().toISOString(),
        cropEnabled: !!state.crop.enabled,
        frameAspect: $("frameAspect").value,
        maxSide: parseInt($("maxSide").value,10) || 1280
      }
    };

    await postJSON(base + "/save", { keyword, payload });
    setStatus("å„²å­˜æˆåŠŸ âœ…");
    pushHistory("save");
    alert("å„²å­˜æˆåŠŸï¼\nè§¸ç™¼é—œéµå­—ï¼šã€Œ" + keyword + "ã€");
  }catch(e){
    setStatus("å„²å­˜å¤±æ•—");
    alert("å„²å­˜å¤±æ•—ï¼š\n" + e.message);
  }
}

async function loadConfig(){
  const base = normalizeWorkerUrl($("workerUrl").value);
  const keyword = $("triggerKeyword").value.trim();
  if(!base || !keyword) return alert("è«‹å¡« Worker URL + è§¸ç™¼é—œéµå­—");
  localStorage.setItem("line_worker_url", base);

  try{
    const data = await postJSON(base + "/load", { keyword });
    const obj = (typeof data === "string") ? JSON.parse(data) : data;

    if(obj.mode !== "imagemap" || !obj.messages?.[0]) throw new Error("ä¸æ˜¯ imagemap æ ¼å¼");
    const m = obj.messages[0];

    state.imageUrl = m.baseUrl;
    state.meta = obj.meta || obj.payload?.meta || obj.payload?.meta || obj.meta || { name:"" };
    state.meta.name = (obj.meta?.name || obj.payload?.meta?.name || "") || "";

    $("fileName").value = state.meta.name || "";

    // restore crop preference (best effort)
    const meta = obj.meta || obj.payload?.meta || {};
    const cropEnabled = !!meta.cropEnabled;
    $("cropEnabled").checked = cropEnabled;

    if(cropEnabled){
      enterCropMode(true);
      $("cropImg").src = state.imageUrl;
      await setupCropFromImage(false, true);
    }else{
      exitCropMode(true);
      $("preview").src = state.imageUrl;
      $("lineFrameNormal").classList.remove("hidden");
      $("lineFrameTagNormal").textContent = `LINE å»ºè­°ç¯„åœï¼ˆâ‰¤${parseInt($("maxSide").value,10)||1280}pxï¼‰`;
    }

    const bw = m.baseSize?.width || 1040;
    const bh = m.baseSize?.height || 1040;

    state.areas = (m.actions || []).map(a => ({
      x: (a.area?.x || 0) / bw,
      y: (a.area?.y || 0) / bh,
      w: (a.area?.width || 0) / bw,
      h: (a.area?.height || 0) / bh,
      text: a.text || ""
    }));

    selectedIndex = -1;
    pushHistory("load");

    renderAreas();
    renderAreaList();
    refreshPhonePreview();

    setStatus("è®€å–æˆåŠŸ âœ…");
    togglePreviewDrawer(true);
    fitToView();
  }catch(e){
    setStatus("è®€å–å¤±æ•—");
    alert("è®€å–å¤±æ•—ï¼š\n" + e.message);
  }
}

/* ------------------- LIFF send test ------------------- */
async function sendTestToMe(){
  if(!isReady) return alert("LIFF å°šæœªåˆå§‹åŒ–å®Œæˆ");
  if(!liff.isInClient()) return alert("è«‹åœ¨ LINE å…§é–‹å•Ÿï¼ˆå½ˆçª—ï¼‰æ‰å¯é€æ¸¬è©¦è¨Šæ¯");
  try{
    const msg = await buildImagemapMessage();
    await liff.sendMessages([msg]);
    alert("å·²æŠŠ imagemap é€åˆ°ä½ ç›®å‰çš„èŠå¤©å®¤ âœ…");
  }catch(e){
    alert("é€æ¸¬è©¦å¤±æ•—ï¼š\n" + e.message);
  }
}
async function sendPreviewToMe(){ return sendTestToMe(); }

/* ------------------- Preview drawer ------------------- */
$("showHotspots").addEventListener("change", () => refreshPhonePreview());

function togglePreviewDrawer(open){
  const overlay = $("drawerOverlay");
  const drawer = $("previewDrawer");
  if(open){
    overlay.classList.remove("hidden");
    drawer.classList.remove("translate-y-full");
    refreshPhonePreview();
  }else{
    overlay.classList.add("hidden");
    drawer.classList.add("translate-y-full");
  }
}

function refreshPhonePreview(){
  const img = $("phoneImg");
  const wrap = $("phoneHotspots");

  if(!state.imageUrl){
    img.src = "";
    wrap.innerHTML = "";
    return;
  }

  img.src = state.imageUrl;
  wrap.innerHTML = "";

  requestAnimationFrame(() => {
    const show = $("showHotspots").checked;
    const r = wrap.getBoundingClientRect();
    if(!r.width || !r.height) return;

    state.areas.forEach((a, i) => {
      if(show){
        const box = document.createElement("div");
        box.className = "preview-hotspot";
        box.style.left = (a.x * r.width) + "px";
        box.style.top  = (a.y * r.height) + "px";
        box.style.width  = (a.w * r.width) + "px";
        box.style.height = (a.h * r.height) + "px";
        wrap.appendChild(box);
      }

      const btn = document.createElement("button");
      btn.style.position="absolute";
      btn.style.left = (a.x*100)+"%";
      btn.style.top  = (a.y*100)+"%";
      btn.style.width = (a.w*100)+"%";
      btn.style.height= (a.h*100)+"%";
      btn.style.background="transparent";
      btn.onclick = () => alert(`ç†±å€ ${i+1}\nå°‡é€å‡ºï¼š${(a.text||"").trim() || "ï¼ˆå°šæœªå¡«ï¼‰"}`);
      wrap.appendChild(btn);
    });
  });
}

/* ------------------- LIFF init / close ------------------- */
async function initLIFF(){
  try{
    $("liffState").textContent = "åˆå§‹åŒ–ä¸­...";
    await liff.init({ liffId: LIFF_ID });

    if(!liff.isLoggedIn()){
      $("liffState").textContent = "éœ€è¦ç™»å…¥";
      liff.login();
      return;
    }

    $("liffState").textContent = liff.isInClient() ? "LINE å…§ï¼ˆå½ˆçª—ï¼‰" : "å¤–éƒ¨ç€è¦½å™¨";
    if(liff.getProfile){
      const p = await liff.getProfile();
      $("userName").textContent = p.displayName || "-";
    }

    const savedUrl = localStorage.getItem("line_worker_url");
    if(savedUrl) $("workerUrl").value = savedUrl;

    isReady = true;
    setStatus("å°±ç·’ âœ…ï¼ˆå¯ä¸Šå‚³ã€ç•«æ¡†ã€è£åˆ‡ã€å„²å­˜ï¼‰");

    // init history
    pushHistory("init");
  }catch(e){
    $("liffState").textContent = "åˆå§‹åŒ–å¤±æ•—";
    setStatus("åˆå§‹åŒ–å¤±æ•—");
    alert("LIFF åˆå§‹åŒ–å¤±æ•—ï¼š\n" + e.message);
  }
}

function closeLiff(){
  if(window.liff && liff.isInClient()) liff.closeWindow();
  else window.close();
}

/* ------------------- Meta name change -> history ------------------- */
$("fileName").addEventListener("input", () => {
  state.meta.name = ($("fileName").value || "").trim();
  pushHistory("rename");
});

/* ------------------- On image load (normal) ------------------- */
$("preview").addEventListener("load", () => {
  if(!state.imageUrl) return;
  // show LINE frame tag (normal mode)
  const maxSide = parseInt($("maxSide").value,10) || 1280;
  $("lineFrameNormal").classList.remove("hidden");
  $("lineFrameTagNormal").textContent = `LINE å»ºè­°ç¯„åœï¼ˆâ‰¤${maxSide}pxï¼‰`;

  updateSizeInfo($("preview").naturalWidth, $("preview").naturalHeight);
  renderAreas();
  refreshPhonePreview();
  fitToView();
});

$("cropImg").addEventListener("load", async () => {
  if(!state.imageUrl || !state.crop.enabled) return;
  await setupCropFromImage(true, false);
  renderAreas();
  refreshPhonePreview();
  fitToView();
});

/* ------------------- Start ------------------- */
initLIFF();
</script>

</body>
</html>
