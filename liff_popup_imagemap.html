<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LINE OA å½ˆçª—ç†±å€ç·¨è¼¯å™¨ï¼ˆCanva ä»‹é¢ç‰ˆï¼‰</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://static.line-scdn.net/liff/edge/2/sdk.js"></script>
  <style>
    :root{
      --rail-w: 76px;
      --panel-w: 340px;
    }
    body{ user-select:none; }
    input, textarea, select, button { user-select:auto; }

    /* å·¥ä½œå€ï¼šæ£‹ç›¤èƒŒæ™¯ */
    .checker{
      background-image:
        linear-gradient(45deg, rgba(0,0,0,.04) 25%, transparent 25%),
        linear-gradient(-45deg, rgba(0,0,0,.04) 25%, transparent 25%),
        linear-gradient(45deg, transparent 75%, rgba(0,0,0,.04) 75%),
        linear-gradient(-45deg, transparent 75%, rgba(0,0,0,.04) 75%);
      background-size: 28px 28px;
      background-position: 0 0, 0 14px, 14px -14px, -14px 0px;
    }

    /* Artboardï¼ˆLINE åº•æ¡†ï¼‰ */
    .artboard{
      position:absolute;
      left:50%; top:50%;
      transform: translate(-50%, -50%);
      background:#fff;
      border:1px solid rgba(15,23,42,.18);
      box-shadow: 0 12px 30px rgba(0,0,0,.12);
      border-radius: 14px;
      overflow:hidden;
    }
    .artboard::before{
      content:"";
      position:absolute;
      inset:0;
      background: linear-gradient(to bottom, rgba(0,0,0,.05), transparent 25%, transparent 75%, rgba(0,0,0,.05));
      pointer-events:none;
      opacity:.45;
    }

    /* å½±åƒå±¤ï¼ˆè£åˆ‡æ™‚æ‹–å‹•ï¼‰ */
    .img-layer{
      position:absolute;
      inset:0;
      overflow:hidden;
      cursor: default;
      background:#f8fafc;
    }
    .img-layer img{
      position:absolute;
      left:50%; top:50%;
      transform: translate(-50%, -50%);
      transform-origin: center center;
      max-width:none;
      max-height:none;
      pointer-events:none;
      user-select:none;
    }

    /* ç†±å€æ¡† */
    .hotspot{
      position:absolute;
      border:2px solid rgba(239,68,68,.95);
      background: rgba(239,68,68,.18);
      border-radius: 10px;
      color:white;
      font-weight:800;
      font-size:12px;
      display:flex;
      align-items:center;
      justify-content:center;
      text-shadow:0 1px 2px rgba(0,0,0,.85);
      cursor:pointer;
    }
    .hotspot.selected{
      border-color: rgba(59,130,246,.95);
      background: rgba(59,130,246,.16);
    }

    /* æ‹‰è§’ handle */
    .handle{
      position:absolute;
      width:10px; height:10px;
      background:#fff;
      border:2px solid rgba(59,130,246,.95);
      border-radius: 4px;
      box-shadow:0 1px 3px rgba(0,0,0,.25);
      z-index: 10;
    }
    .handle.nw{ left:-6px; top:-6px; cursor:nwse-resize; }
    .handle.ne{ right:-6px; top:-6px; cursor:nesw-resize; }
    .handle.sw{ left:-6px; bottom:-6px; cursor:nesw-resize; }
    .handle.se{ right:-6px; bottom:-6px; cursor:nwse-resize; }

    /* æ‹–æ›³æ–°æ¡†æ™‚çš„é è¦½ */
    .draw-rect{
      position:absolute;
      border:2px dashed rgba(2,6,23,.55);
      background: rgba(2,6,23,.12);
      border-radius: 10px;
      pointer-events:none;
    }

    /* å°æç¤º */
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      border:1px solid rgba(0,0,0,.18);
      padding:2px 6px;
      border-radius:6px;
      background:#fff;
      font-size: 11px;
    }
  </style>
</head>
<body class="bg-slate-100 text-slate-800 overflow-hidden">

<!-- Top barï¼ˆåƒ Canvaï¼‰ -->
<div class="h-14 bg-white border-b flex items-center justify-between px-3">
  <div class="flex items-center gap-3">
    <div class="font-extrabold text-blue-700">LINE OA å½ˆçª—ç†±å€ç·¨è¼¯å™¨ï¼ˆCanva ä»‹é¢ç‰ˆï¼‰</div>
    <div class="hidden md:flex items-center gap-2 text-xs text-slate-500">
      <span>ç©ºç™½éµæ‹–æ›³å¹³ç§»</span>
      <span>ï½œ</span>
      <span>Ctrl + æ»¾è¼ªç¸®æ”¾</span>
      <span>ï½œ</span>
      <span>Ctrl+Z / Ctrl+Y Undo/Redo</span>
      <span>ï½œ</span>
      <span>Delete åˆªé™¤é¸å–æ¡†</span>
    </div>
  </div>
  <div class="flex items-center gap-2">
    <button class="px-3 py-2 rounded bg-slate-900 text-white text-sm hover:bg-black" onclick="togglePreview(true)">
      ğŸ“± é è¦½
    </button>
    <button class="px-3 py-2 rounded bg-slate-700 text-white text-sm hover:bg-slate-900" onclick="closeLiff()">
      é—œé–‰
    </button>
  </div>
</div>

<!-- Main layout -->
<div class="h-[calc(100vh-56px)] flex">

  <!-- Left railï¼ˆCanva å·¦é‚Šç›´æ¬„ï¼‰ -->
  <div id="rail" class="w-[76px] bg-white border-r flex flex-col items-center py-3 gap-2">
    <button class="w-12 h-12 rounded-xl bg-slate-900 text-white flex items-center justify-center text-xl hover:bg-black"
            title="æ”¶åˆ/å±•é–‹å·¥å…·åˆ—"
            onclick="togglePanel()">
      â˜°
    </button>

    <button class="w-12 h-12 rounded-xl bg-slate-100 hover:bg-slate-200 flex items-center justify-center text-xl"
            title="ç†±å€ç·¨è¼¯æ¨¡å¼"
            onclick="setMode('hotspot')">ğŸ”²</button>

    <button class="w-12 h-12 rounded-xl bg-slate-100 hover:bg-slate-200 flex items-center justify-center text-xl"
            title="è£åˆ‡æ¨¡å¼ï¼ˆæ‹–åœ–ç‰‡æ±ºå®šè£åˆ‡ä½ç½®ï¼‰"
            onclick="setMode('crop')">âœ‚ï¸</button>

    <button class="w-12 h-12 rounded-xl bg-slate-100 hover:bg-slate-200 flex items-center justify-center text-xl"
            title="Fit"
            onclick="fitToScreen()">ğŸ“</button>

    <button class="w-12 h-12 rounded-xl bg-slate-100 hover:bg-slate-200 flex items-center justify-center text-xl"
            title="é‡ç½®ç¸®æ”¾"
            onclick="resetView()">ğŸ”</button>
  </div>

  <!-- Left panelï¼ˆå¯æ”¶åˆï¼‰ -->
  <div id="panel" class="w-[340px] bg-white border-r overflow-y-auto">
    <div class="p-4 space-y-4">

      <!-- åŸºæœ¬é€£ç·š -->
      <div class="rounded-xl border p-3 bg-slate-50">
        <div class="font-bold text-sm mb-2">åŸºæœ¬è¨­å®š</div>

        <label class="text-xs text-slate-500">Worker URL</label>
        <input id="workerUrl" class="mt-1 w-full border rounded px-3 py-2 bg-yellow-50 text-sm"
               placeholder="https://xxx.workers.dev" />

        <div class="grid grid-cols-2 gap-2 mt-2">
          <div>
            <label class="text-xs text-slate-500">è§¸ç™¼é—œéµå­—</label>
            <input id="triggerKeyword" class="mt-1 w-full border rounded px-3 py-2 text-sm font-bold border-blue-500"
                   placeholder="ä½¿ç”¨è€…è¼¸å…¥é€™å¥æœƒå‡ºç¾åœ–" />
          </div>
          <div>
            <label class="text-xs text-slate-500">æª”æ¡ˆåç¨±ï¼ˆç”¨ä¾†ç¯©é¸ï¼‰</label>
            <input id="fileName" class="mt-1 w-full border rounded px-3 py-2 text-sm font-bold"
                   placeholder="ä¾‹å¦‚ï¼š2026-02-é£²é£Ÿèœå–®_å½ˆçª—ç†±å€" />
          </div>
        </div>

        <div class="mt-2 text-xs text-slate-500">
          æœƒå­˜åˆ° <span class="kbd">payload.meta.name</span>ï¼Œä¹‹å¾Œä½ åšçš„ <span class="kbd">lab_dashboard</span> å°±èƒ½ç”¨å®ƒç¯©é¸å†ç·¨è¼¯ã€‚
        </div>

        <div id="status" class="mt-2 text-xs text-slate-500">ç‹€æ…‹ï¼šæœªåˆå§‹åŒ–</div>
      </div>

      <!-- LINE åº•æ¡† -->
      <div class="rounded-xl border p-3">
        <div class="font-bold text-sm mb-2 flex items-center justify-between">
          <span>LINE åº•æ¡†ï¼ˆArtboardï¼‰</span>
          <span class="text-xs text-slate-500">å¯¬å›ºå®š 1040</span>
        </div>

        <div class="grid grid-cols-2 gap-2">
          <label class="text-xs text-slate-500">
            é«˜åº¦æ¯”ä¾‹
            <select id="framePreset" class="mt-1 w-full border rounded px-2 py-2 text-sm" onchange="applyFramePreset()">
              <option value="1">1:1ï¼ˆ1040Ã—1040ï¼‰</option>
              <option value="1.5">1:1.5ï¼ˆ1040Ã—1560ï¼‰</option>
              <option value="2">1:2ï¼ˆ1040Ã—2080ï¼‰</option>
            </select>
          </label>

          <label class="text-xs text-slate-500">
            é¡¯ç¤ºå®‰å…¨æ¡†
            <select id="safeFrame" class="mt-1 w-full border rounded px-2 py-2 text-sm" onchange="renderSafety()">
              <option value="on" selected>é–‹</option>
              <option value="off">é—œ</option>
            </select>
          </label>
        </div>

        <div class="mt-2 text-xs text-slate-500">
          ä½ ç¾åœ¨çœ‹åˆ°çš„ç™½è‰²åº•æ¡†ï¼Œå°±æ˜¯ã€ŒLINE å°ºå¯¸åŸºæº–ã€ã€‚åœ–ç‰‡è¶…å‡ºåº•æ¡†æ™‚ï¼Œç”¨ <span class="kbd">è£åˆ‡æ¨¡å¼</span> æ‹–å‹•åœ–ç‰‡æ±ºå®šè£åˆ‡ä½ç½®ã€‚
        </div>
      </div>

      <!-- åœ–ç‰‡ / ä¸Šå‚³ -->
      <div class="rounded-xl border p-3">
        <div class="font-bold text-sm mb-2">åœ–ç‰‡ï¼ˆä¸Šå‚³åˆ° R2ï¼‰</div>

        <div class="grid grid-cols-2 gap-2 text-xs">
          <label class="flex flex-col gap-1">
            <span class="text-slate-500">é•·é‚Šä¸Šé™</span>
            <select id="maxSide" class="border rounded px-2 py-2 text-sm">
              <option value="960">960ï¼ˆçœç©ºé–“ï¼‰</option>
              <option value="1280" selected>1280ï¼ˆLINE å»ºè­°ï¼‰</option>
              <option value="1600">1600ï¼ˆæ›´æ¸…æ™°ï¼‰</option>
            </select>
          </label>
          <label class="flex flex-col gap-1">
            <span class="text-slate-500">æ ¼å¼</span>
            <select id="outFormat" class="border rounded px-2 py-2 text-sm">
              <option value="image/webp" selected>WebPï¼ˆæ¨è–¦ï¼‰</option>
              <option value="image/jpeg">JPEG</option>
            </select>
          </label>

          <label class="flex flex-col gap-1 col-span-2">
            <span class="text-slate-500">å“è³ª <span id="qVal">0.82</span></span>
            <input id="quality" type="range" min="0.55" max="0.95" step="0.01" value="0.82">
          </label>

          <label class="flex items-center gap-2 col-span-2">
            <input id="cropSquare" type="checkbox" class="scale-110">
            <span class="text-slate-600">å…ˆè£åˆ‡æ­£æ–¹å½¢ï¼ˆå¸¸ç”¨ï¼Œéå¿…è¦ï¼‰</span>
          </label>
        </div>

        <div class="mt-3 flex flex-wrap gap-2">
          <button class="px-3 py-2 rounded bg-blue-600 text-white text-sm hover:bg-blue-700" onclick="pickAndUpload()">
            ä¸Šå‚³åœ–ç‰‡åˆ° R2
          </button>
          <button class="px-3 py-2 rounded bg-slate-900 text-white text-sm hover:bg-black" onclick="exportCropAndUpload()">
            ä¾è£åˆ‡è¼¸å‡ºä¸¦ä¸Šå‚³
          </button>
          <button class="px-3 py-2 rounded bg-slate-600 text-white text-sm hover:bg-slate-700" onclick="clearAll()">
            æ¸…ç©º
          </button>
        </div>

        <div class="mt-2 text-xs text-slate-500">
          * å»ºè­°æµç¨‹ï¼šå…ˆä¸Šå‚³ â†’ é€²è£åˆ‡æ¨¡å¼èª¿æ•´ â†’ æŒ‰ã€Œä¾è£åˆ‡è¼¸å‡ºä¸¦ä¸Šå‚³ã€ç”¢ç”ŸçœŸæ­£ç¬¦åˆåº•æ¡†çš„åœ–ç‰‡ã€‚
        </div>
      </div>

      <!-- ç†±å€åˆ—è¡¨ -->
      <div class="rounded-xl border p-3">
        <div class="font-bold text-sm mb-2 flex items-center justify-between">
          <span>ç†±å€æ¸…å–®</span>
          <span id="hsCount" class="text-xs text-slate-500">0</span>
        </div>

        <div id="areaEmpty" class="text-xs text-slate-400">å°šæœªæ–°å¢ç†±å€ã€‚ç”¨æ»‘é¼ åœ¨åº•æ¡†å…§æ‹–æ›³å³å¯æ–°å¢ã€‚</div>
        <div id="areaList" class="space-y-2"></div>

        <div class="mt-3 flex gap-2">
          <button class="flex-1 px-3 py-2 rounded bg-gray-600 text-white text-sm hover:bg-gray-700" onclick="loadConfig()">
            è®€å–
          </button>
          <button class="flex-1 px-3 py-2 rounded bg-green-600 text-white text-sm hover:bg-green-700" onclick="saveConfig()">
            å„²å­˜
          </button>
        </div>

        <div class="mt-2 text-xs text-slate-500">
          ç†±å€ã€Œå…§å®¹ã€ï¼é»åˆ°æ™‚é€å‡ºçš„æ–‡å­—ï¼ˆä½ ç”¨ä¾†è§¸ç™¼è‡ªå‹•å›è¦†çš„é—œéµå­—ï¼‰ã€‚
        </div>
      </div>

      <!-- LIFF -->
      <div class="rounded-xl border p-3 bg-slate-50">
        <div class="font-bold text-sm mb-2">LIFF / ä½¿ç”¨è€…</div>
        <div class="text-xs text-slate-600 space-y-1">
          <div>LIFFï¼š<span id="liffState" class="font-bold">-</span></div>
          <div>ä½¿ç”¨è€…ï¼š<span id="userName" class="font-bold">-</span></div>
          <div class="text-[11px] text-slate-500">åœ¨ LINE å…§é–‹å•Ÿå¯ç›´æ¥ã€Œé€åˆ°æˆ‘æ¸¬è©¦ã€ã€‚</div>
        </div>

        <div class="mt-3 flex gap-2">
          <button class="flex-1 px-3 py-2 rounded bg-black text-white text-sm hover:bg-slate-900" onclick="sendTestToMe()">
            é€åˆ°æˆ‘æ¸¬è©¦
          </button>
          <button class="flex-1 px-3 py-2 rounded bg-slate-200 text-slate-700 text-sm hover:bg-slate-300" onclick="togglePreview(true)">
            é è¦½æŠ½å±œ
          </button>
        </div>
      </div>

      <div class="text-xs text-slate-400 pb-10">
        Powered by Cloudflare Workers & KV / R2
      </div>
    </div>
  </div>

  <!-- Workspace -->
  <div class="flex-1 relative checker overflow-hidden" id="workspace">
    <!-- zoom HUD -->
    <div class="absolute top-3 right-3 z-20 flex items-center gap-2 bg-white/90 backdrop-blur border rounded-xl px-2 py-1 shadow">
      <button class="px-2 py-1 rounded hover:bg-slate-100 text-sm" onclick="zoomBy(1.1)">ï¼‹</button>
      <div class="w-16 text-center text-sm font-bold" id="zoomLabel">100%</div>
      <button class="px-2 py-1 rounded hover:bg-slate-100 text-sm" onclick="zoomBy(1/1.1)">ï¼</button>
      <button class="px-2 py-1 rounded bg-slate-900 text-white text-sm hover:bg-black" onclick="fitToScreen()">Fit</button>
    </div>

    <!-- Workspace transform (pan/zoom) -->
    <div id="stage" class="absolute inset-0">
      <!-- Artboard -->
      <div id="artboard" class="artboard">
        <div id="imgLayer" class="img-layer">
          <img id="img" alt="">
          <!-- safety overlay -->
          <div id="safety" class="absolute inset-0 pointer-events-none"></div>
        </div>
        <div id="hotspotLayer" class="absolute inset-0"></div>
        <div id="drawLayer" class="absolute inset-0"></div>
      </div>
    </div>

    <!-- Bottom hint -->
    <div class="absolute left-3 bottom-3 z-20 bg-white/90 backdrop-blur border rounded-xl px-3 py-2 shadow text-xs text-slate-600">
      <div class="font-bold mb-1">æ“ä½œæç¤º</div>
      <div class="space-y-1">
        <div>â€¢ ç†±å€æ¨¡å¼ï¼šåº•æ¡†å…§æ‹–æ›³æ–°å¢ï¼›é»æ¡†é¸å–ï¼›æ‹–ç§»ï¼æ‹‰è§’ç¸®æ”¾ï¼›<span class="kbd">Delete</span> åˆªé™¤</div>
        <div>â€¢ è£åˆ‡æ¨¡å¼ï¼šæ‹–å‹•åœ–ç‰‡æ±ºå®šè£åˆ‡ä½ç½®ï¼›<span class="kbd">Ctrl</span>+æ»¾è¼ªç¸®æ”¾åœ–ç‰‡ï¼›å†æŒ‰ã€Œä¾è£åˆ‡è¼¸å‡ºä¸¦ä¸Šå‚³ã€</div>
        <div>â€¢ è¦–è§’ï¼š<span class="kbd">ç©ºç™½éµ</span> æŒ‰ä½æ‹–æ›³å¹³ç§»ï¼›<span class="kbd">Ctrl</span>+æ»¾è¼ªç¸®æ”¾ç•«é¢</div>
      </div>
    </div>
  </div>
</div>

<!-- Preview Drawer -->
<div id="drawerOverlay" class="fixed inset-0 bg-black/40 hidden z-40" onclick="togglePreview(false)"></div>
<div id="previewDrawer" class="fixed left-0 right-0 bottom-0 z-50 translate-y-full transition-transform duration-300 ease-out">
  <div class="mx-auto max-w-4xl">
    <div class="bg-white rounded-t-2xl shadow-2xl overflow-hidden">
      <div class="flex items-center justify-between px-4 py-3 border-b">
        <div class="font-bold text-slate-700">ğŸ“± æ‰‹æ©Ÿé è¦½ï¼ˆèŠå¤©æ³¡æ³¡å¯¬åº¦æ„Ÿï¼‰</div>
        <div class="flex items-center gap-2">
          <label class="flex items-center gap-2 text-xs text-slate-600">
            <input id="showHotspots" type="checkbox" checked>
            é¡¯ç¤ºç†±å€æ¡†
          </label>
          <button class="px-3 py-1.5 rounded bg-slate-200 text-slate-700 text-sm hover:bg-slate-300" onclick="togglePreview(false)">æ”¶èµ·</button>
        </div>
      </div>
      <div class="p-4 bg-slate-50">
        <div class="mx-auto w-[360px] max-w-full">
          <div class="rounded-[26px] border-4 border-slate-900 bg-slate-900 p-2">
            <div class="rounded-[20px] bg-white overflow-hidden">
              <div class="bg-slate-100 text-xs text-slate-600 px-3 py-2 border-b flex items-center justify-between">
                <span>é è¦½</span>
                <button class="text-[11px] px-2 py-1 rounded bg-white border hover:bg-slate-50" onclick="sendPreviewToMe()">
                  ç›´æ¥é€åˆ°æˆ‘æ¸¬è©¦
                </button>
              </div>
              <div class="p-3">
                <div class="mx-auto w-[320px] max-w-full">
                  <div class="text-[11px] text-slate-500 mb-2">é»ç†±å€æœƒæç¤ºé€å‡ºçš„é—œéµå­—ï¼ˆæ¨¡æ“¬ç”¨æˆ¶é»é¸ï¼‰</div>
                  <div class="relative rounded-lg overflow-hidden border bg-white">
                    <img id="phoneImg" class="w-full h-[220px] object-cover bg-gray-100">
                    <div id="phoneHotspots" class="absolute inset-0"></div>
                  </div>
                  <div class="mt-2 text-[11px] text-slate-500">* å¯¦éš›æœƒå› æ‰‹æ©Ÿç•¥æœ‰å·®ç•°</div>
                </div>
              </div>
            </div>
          </div>

          <div class="mt-3 flex gap-2">
            <button class="flex-1 px-3 py-2 rounded bg-slate-900 text-white text-sm hover:bg-black" onclick="togglePreview(false)">æ”¶èµ·</button>
            <button class="flex-1 px-3 py-2 rounded bg-blue-600 text-white text-sm hover:bg-blue-700" onclick="refreshPhonePreview()">é‡æ–°æ¸²æŸ“</button>
          </div>
        </div>
      </div>
      <div class="px-4 py-3 bg-white border-t text-xs text-slate-500">
        ä½ ç•«æ¡†æˆ–æ”¹æ–‡å­—å¾Œæœƒè‡ªå‹•æ›´æ–°ï¼›æ²’æ›´æ–°å°±æŒ‰ã€Œé‡æ–°æ¸²æŸ“ã€ã€‚
      </div>
    </div>
  </div>
</div>

<input type="file" id="fileInput" accept="image/*" hidden>

<script>
/* ===================== ä½ åªè¦æ”¹é€™è£¡ ===================== */
const LIFF_ID = "2009037126-AD8Dolxb";
/* ======================================================= */

/* ========= DOM ========= */
const $ = (id) => document.getElementById(id);

const workerUrlEl = $("workerUrl");
const triggerEl = $("triggerKeyword");
const fileNameEl = $("fileName");
const statusEl = $("status");
const liffStateEl = $("liffState");
const userNameEl = $("userName");

const panelEl = $("panel");
const railEl = $("rail");

const workspaceEl = $("workspace");
const stageEl = $("stage");

const artboardEl = $("artboard");
const imgLayerEl = $("imgLayer");
const imgEl = $("img");
const safetyEl = $("safety");

const hotspotLayerEl = $("hotspotLayer");
const drawLayerEl = $("drawLayer");

const areaListEl = $("areaList");
const areaEmptyEl = $("areaEmpty");
const hsCountEl = $("hsCount");

const zoomLabelEl = $("zoomLabel");

/* ========= helpers ========= */
function normalizeWorkerUrl(raw){
  if(!raw) return "";
  let s = raw.trim();
  if(!/^https?:\/\//i.test(s)) s = "https://" + s;
  return s.replace(/\/+$/,'');
}
function setStatus(msg){ statusEl.textContent = "ç‹€æ…‹ï¼š" + msg; }

function escapeHtml(str){
  return String(str||"")
    .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
    .replaceAll('"',"&quot;").replaceAll("'","&#039;");
}

async function postJSON(url, data){
  const res = await fetch(url, {
    method:"POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify(data)
  });
  if(!res.ok){
    const t = await res.text().catch(()=> "");
    throw new Error(`HTTP ${res.status}\n${t}`);
  }
  const ct = res.headers.get("content-type") || "";
  return ct.includes("json") ? res.json() : res.text();
}

async function uploadToR2(workerBaseUrl, fileBlob, filename){
  const form = new FormData();
  form.append("file", fileBlob, filename || "image.webp");
  const res = await fetch(workerBaseUrl + "/upload", { method:"POST", body: form });
  if(!res.ok){
    const t = await res.text().catch(()=> "");
    throw new Error(`HTTP ${res.status}\n${t}`);
  }
  const j = await res.json();
  if(!j.ok || !j.url) throw new Error("ä¸Šå‚³å›å‚³æ ¼å¼ä¸å°");
  return j.url;
}

/* ========= state =========
hotspots: normalized to artboard [0..1]
crop: image transform inside artboard
*/
let state = {
  meta: { name: "" },
  triggerKeyword: "",
  imageUrl: "",
  // we keep original uploaded blob for crop-export if possible
  _sourceBlob: null,
  _sourceName: "image",
  frame: { w: 1040, h: 1040 }, // LINE base
  mode: "hotspot",            // "hotspot" | "crop"
  crop: { tx: 0, ty: 0, s: 1 },// image translate(px) relative to center + scale
  hotspots: [],
  selectedId: null
};

let isReady = false;

/* ========= history (Undo/Redo) ========= */
let history = [];
let historyIndex = -1;
function cloneForHistory(s){
  // remove blobs for history to avoid heavy memory
  return JSON.parse(JSON.stringify({
    meta: s.meta,
    triggerKeyword: s.triggerKeyword,
    imageUrl: s.imageUrl,
    frame: s.frame,
    mode: s.mode,
    crop: s.crop,
    hotspots: s.hotspots,
    selectedId: s.selectedId
  }));
}
function applyHistorySnap(snap){
  state.meta = snap.meta;
  state.triggerKeyword = snap.triggerKeyword;
  state.imageUrl = snap.imageUrl;
  state.frame = snap.frame;
  state.mode = snap.mode;
  state.crop = snap.crop;
  state.hotspots = snap.hotspots;
  state.selectedId = snap.selectedId;
  // UI sync
  triggerEl.value = state.triggerKeyword || "";
  fileNameEl.value = (state.meta?.name || "");
  $("framePreset").value = (state.frame.h / state.frame.w).toString();
  applyFramePreset(true);
  setMode(state.mode, true);
  setImageUrl(state.imageUrl, true);
  renderAll();
}
function pushHistory(){
  const snap = cloneForHistory(state);
  // discard forward
  history = history.slice(0, historyIndex + 1);
  history.push(snap);
  historyIndex++;
}
function undo(){
  if(historyIndex <= 0) return;
  historyIndex--;
  applyHistorySnap(history[historyIndex]);
}
function redo(){
  if(historyIndex >= history.length - 1) return;
  historyIndex++;
  applyHistorySnap(history[historyIndex]);
}

/* ========= view (pan/zoom) ========= */
let view = { x: 0, y: 0, z: 1 };
function updateStageTransform(){
  stageEl.style.transform = `translate(${view.x}px, ${view.y}px) scale(${view.z})`;
  zoomLabelEl.textContent = Math.round(view.z * 100) + "%";
}
function resetView(){
  view = { x: 0, y: 0, z: 1 };
  updateStageTransform();
}
function zoomBy(factor, anchorClientX=null, anchorClientY=null){
  const oldZ = view.z;
  const newZ = Math.min(4, Math.max(0.2, oldZ * factor));

  if(anchorClientX != null && anchorClientY != null){
    // keep anchor stable
    const rect = workspaceEl.getBoundingClientRect();
    const ax = anchorClientX - rect.left;
    const ay = anchorClientY - rect.top;

    const dx = ax - (rect.width/2);
    const dy = ay - (rect.height/2);

    // adjust pan so anchor stays
    view.x = (view.x - dx) * (newZ/oldZ) + dx;
    view.y = (view.y - dy) * (newZ/oldZ) + dy;
  }

  view.z = newZ;
  updateStageTransform();
}
function fitToScreen(){
  // fit artboard into workspace
  const wr = workspaceEl.getBoundingClientRect();
  const pad = 120;
  const maxW = Math.max(200, wr.width - pad);
  const maxH = Math.max(200, wr.height - pad);

  const abW = state.frame.w;
  const abH = state.frame.h;

  const z = Math.min(3, Math.max(0.2, Math.min(maxW/abW, maxH/abH)));
  view.z = z;
  view.x = 0; view.y = 0;
  updateStageTransform();
}

/* ========= panel collapse ========= */
let panelCollapsed = false;
function togglePanel(){
  panelCollapsed = !panelCollapsed;
  panelEl.classList.toggle("hidden", panelCollapsed);
}

/* ========= frame preset ========= */
function applyFramePreset(silent=false){
  const ratio = parseFloat($("framePreset").value || "1");
  state.frame.w = 1040;
  state.frame.h = Math.round(1040 * ratio);

  // apply artboard size in CSS px (use 1:1 scale mapping)
  artboardEl.style.width = state.frame.w + "px";
  artboardEl.style.height = state.frame.h + "px";

  renderSafety();
  if(!silent) pushHistory();
  // keep fit nice
  fitToScreen();
}
function renderSafety(){
  safetyEl.innerHTML = "";
  const on = ($("safeFrame").value === "on");
  if(!on) return;

  // safe margin 24px for visual guide
  const m = 24;
  const box = document.createElement("div");
  box.style.position = "absolute";
  box.style.left = m + "px";
  box.style.top = m + "px";
  box.style.right = m + "px";
  box.style.bottom = m + "px";
  box.style.border = "2px dashed rgba(15,23,42,.25)";
  box.style.borderRadius = "12px";
  safetyEl.appendChild(box);
}

/* ========= mode ========= */
function setMode(mode, silent=false){
  state.mode = mode;
  // cursor hint
  if(mode === "crop"){
    imgLayerEl.style.cursor = "grab";
  }else{
    imgLayerEl.style.cursor = "default";
  }
  if(!silent) pushHistory();
  renderModeBadge();
}
function renderModeBadge(){
  // minimal status update
  const text = state.mode === "crop"
    ? "è£åˆ‡æ¨¡å¼ï¼šæ‹–åœ–ç‰‡æ±ºå®šè£åˆ‡ä½ç½®ï¼ˆCtrl+æ»¾è¼ªç¸®æ”¾åœ–ç‰‡ï¼‰"
    : "ç†±å€æ¨¡å¼ï¼šæ‹–æ›³æ–°å¢æ¡†ï¼›é¸å–æ¡†å¯æ‹–ç§»/æ‹‰è§’ç¸®æ”¾";
  setStatus(text);
}

/* ========= image / crop ========= */
function setImageUrl(url, silent=false){
  state.imageUrl = url || "";
  imgEl.src = state.imageUrl || "";
  if(!state.imageUrl){
    imgEl.removeAttribute("src");
  }
  if(!silent) pushHistory();
  refreshPhonePreview();
}
function applyCropTransform(){
  // apply translate+scale on img
  const t = state.crop;
  imgEl.style.transform = `translate(calc(-50% + ${t.tx}px), calc(-50% + ${t.ty}px)) scale(${t.s})`;
}

/* ========= hotspots ========= */
function uid(){
  return "hs_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
}
function selectHotspot(id){
  state.selectedId = id;
  renderHotspots();
  renderHotspotList();
}
function addHotspot(nx, ny, nw, nh){
  const id = uid();
  state.hotspots.push({ id, x:nx, y:ny, w:nw, h:nh, text:"" });
  state.selectedId = id;
  pushHistory();
  renderAll();
}
function deleteSelected(){
  if(!state.selectedId) return;
  const i = state.hotspots.findIndex(h => h.id === state.selectedId);
  if(i >= 0){
    state.hotspots.splice(i,1);
    state.selectedId = null;
    pushHistory();
    renderAll();
  }
}

/* ========= render ========= */
function renderHotspots(){
  hotspotLayerEl.innerHTML = "";
  const ab = artboardEl.getBoundingClientRect();

  state.hotspots.forEach((h, idx) => {
    const d = document.createElement("div");
    d.className = "hotspot" + (h.id === state.selectedId ? " selected" : "");
    d.style.left = (h.x * 100) + "%";
    d.style.top = (h.y * 100) + "%";
    d.style.width = (h.w * 100) + "%";
    d.style.height = (h.h * 100) + "%";
    d.textContent = (idx + 1);

    d.addEventListener("mousedown", (ev) => {
      ev.stopPropagation();
      if(state.mode !== "hotspot") return;
      selectHotspot(h.id);
      beginDragHotspot(ev, h.id, "move");
    });
    d.addEventListener("click", (ev) => {
      ev.stopPropagation();
      selectHotspot(h.id);
    });

    if(h.id === state.selectedId && state.mode === "hotspot"){
      // handles
      ["nw","ne","sw","se"].forEach(pos=>{
        const hd = document.createElement("div");
        hd.className = "handle " + pos;
        hd.addEventListener("mousedown", (ev)=>{
          ev.stopPropagation();
          beginDragHotspot(ev, h.id, pos);
        });
        d.appendChild(hd);
      });
    }

    hotspotLayerEl.appendChild(d);
  });

  hsCountEl.textContent = state.hotspots.length + " å€‹";
}

function renderHotspotList(){
  areaListEl.innerHTML = "";
  areaEmptyEl.classList.toggle("hidden", state.hotspots.length !== 0);

  state.hotspots.forEach((h, idx) => {
    const row = document.createElement("div");
    row.className = "border rounded-lg p-2 bg-white";
    const selected = (h.id === state.selectedId);

    row.innerHTML = `
      <div class="flex items-center justify-between mb-2">
        <div class="font-bold text-sm ${selected ? 'text-blue-700' : 'text-slate-700'}">æ¡† ${idx+1}</div>
        <div class="flex items-center gap-2">
          <button class="text-xs ${selected ? 'text-blue-700' : 'text-slate-500'} underline">é¸å–</button>
          <button class="text-xs text-red-600 underline">åˆªé™¤</button>
        </div>
      </div>
      <div class="text-xs text-slate-500 mb-1">é»æ­¤æ¡†é€å‡ºæ–‡å­—ï¼š</div>
      <input class="w-full border rounded px-2 py-2 text-sm font-bold"
        placeholder="ä¾‹å¦‚ï¼šMENU_SHOP / MENU_CALENDAR / MENU_NUTRITION"
        value="${escapeHtml(h.text)}">
    `;

    const btnSelect = row.querySelectorAll("button")[0];
    const btnDel = row.querySelectorAll("button")[1];
    const input = row.querySelector("input");

    btnSelect.onclick = () => selectHotspot(h.id);
    btnDel.onclick = () => {
      if(confirm(`åˆªé™¤æ¡† ${idx+1}ï¼Ÿ`)){
        const i = state.hotspots.findIndex(x => x.id === h.id);
        if(i>=0){
          state.hotspots.splice(i,1);
          if(state.selectedId === h.id) state.selectedId = null;
          pushHistory();
          renderAll();
        }
      }
    };
    input.oninput = () => {
      h.text = input.value;
      // small push but not too frequent: push on blur
      refreshPhonePreview();
    };
    input.onblur = () => pushHistory();

    areaListEl.appendChild(row);
  });
}

function renderAll(){
  // sync inputs
  triggerEl.value = state.triggerKeyword || "";
  fileNameEl.value = (state.meta?.name || "");
  // image
  applyCropTransform();
  // layers
  renderHotspots();
  renderHotspotList();
  refreshPhonePreview();
}

/* ========= drawing new hotspot ========= */
let drawing = false;
let drawStart = { x:0, y:0 };
let drawRectEl = null;

function getPointInArtboard(ev){
  const r = artboardEl.getBoundingClientRect();
  return {
    px: ev.clientX - r.left,
    py: ev.clientY - r.top,
    nx: (ev.clientX - r.left) / r.width,
    ny: (ev.clientY - r.top) / r.height,
    r
  };
}

drawLayerEl.addEventListener("mousedown", (ev)=>{
  if(state.mode !== "hotspot") return;
  if(!state.imageUrl) return alert("è«‹å…ˆä¸Šå‚³åœ–ç‰‡ï¼ˆæˆ–å…ˆè®€å–ï¼‰");
  // if clicking on empty area -> start draw
  const p = getPointInArtboard(ev);
  drawing = true;
  drawStart = { x:p.px, y:p.py };

  drawRectEl = document.createElement("div");
  drawRectEl.className = "draw-rect";
  drawRectEl.style.left = drawStart.x + "px";
  drawRectEl.style.top = drawStart.y + "px";
  drawRectEl.style.width = "0px";
  drawRectEl.style.height = "0px";
  drawLayerEl.appendChild(drawRectEl);

  // deselect
  state.selectedId = null;
  renderHotspots();
});

window.addEventListener("mousemove", (ev)=>{
  if(drawing && drawRectEl){
    const r = artboardEl.getBoundingClientRect();
    const cx = ev.clientX - r.left;
    const cy = ev.clientY - r.top;

    const x = Math.min(drawStart.x, cx);
    const y = Math.min(drawStart.y, cy);
    const w = Math.abs(cx - drawStart.x);
    const h = Math.abs(cy - drawStart.y);

    drawRectEl.style.left = x + "px";
    drawRectEl.style.top = y + "px";
    drawRectEl.style.width = w + "px";
    drawRectEl.style.height = h + "px";
  }
});

window.addEventListener("mouseup", (ev)=>{
  if(!drawing) return;
  drawing = false;

  if(drawRectEl){
    const r = artboardEl.getBoundingClientRect();
    const rect = drawRectEl.getBoundingClientRect();
    drawRectEl.remove();
    drawRectEl = null;

    // compute relative to artboard
    const ab = artboardEl.getBoundingClientRect();
    const x = rect.left - ab.left;
    const y = rect.top - ab.top;
    const w = rect.width;
    const h = rect.height;

    if(w < 18 || h < 18) return;

    const nx = x / ab.width;
    const ny = y / ab.height;
    const nw = w / ab.width;
    const nh = h / ab.height;

    addHotspot(nx, ny, nw, nh);
  }
});

/* ========= drag / resize hotspot ========= */
let drag = null;
// drag = { id, kind:"move"|"nw"|"ne"|"sw"|"se", startMouse:{x,y}, startBox:{x,y,w,h} }
function beginDragHotspot(ev, id, kind){
  const h = state.hotspots.find(x=>x.id===id);
  if(!h) return;
  const ab = artboardEl.getBoundingClientRect();
  drag = {
    id, kind,
    ab,
    startMouse: { x: ev.clientX, y: ev.clientY },
    startBox: { x:h.x, y:h.y, w:h.w, h:h.h }
  };
  window.addEventListener("mousemove", onDragHotspot);
  window.addEventListener("mouseup", endDragHotspot, { once:true });
}
function onDragHotspot(ev){
  if(!drag) return;
  const h = state.hotspots.find(x=>x.id===drag.id);
  if(!h) return;

  const dx = (ev.clientX - drag.startMouse.x) / drag.ab.width;
  const dy = (ev.clientY - drag.startMouse.y) / drag.ab.height;

  let nx = drag.startBox.x;
  let ny = drag.startBox.y;
  let nw = drag.startBox.w;
  let nh = drag.startBox.h;

  const min = 0.02;

  if(drag.kind === "move"){
    nx = drag.startBox.x + dx;
    ny = drag.startBox.y + dy;
  }else{
    // resize
    if(drag.kind.includes("n")){
      ny = drag.startBox.y + dy;
      nh = drag.startBox.h - dy;
    }
    if(drag.kind.includes("s")){
      nh = drag.startBox.h + dy;
    }
    if(drag.kind.includes("w")){
      nx = drag.startBox.x + dx;
      nw = drag.startBox.w - dx;
    }
    if(drag.kind.includes("e")){
      nw = drag.startBox.w + dx;
    }
  }

  // clamp
  nw = Math.max(min, nw);
  nh = Math.max(min, nh);
  nx = Math.min(1 - nw, Math.max(0, nx));
  ny = Math.min(1 - nh, Math.max(0, ny));

  h.x = nx; h.y = ny; h.w = nw; h.h = nh;

  renderHotspots();
  refreshPhonePreview();
}
function endDragHotspot(){
  window.removeEventListener("mousemove", onDragHotspot);
  drag = null;
  pushHistory();
  renderHotspotList();
}

/* ========= crop mode drag image ========= */
let cropDrag = null;
// cropDrag = { startMouse, startTxTy }
imgLayerEl.addEventListener("mousedown", (ev)=>{
  if(state.mode !== "crop") return;
  if(!state.imageUrl) return;
  cropDrag = {
    startMouse: { x: ev.clientX, y: ev.clientY },
    start: { tx: state.crop.tx, ty: state.crop.ty }
  };
  imgLayerEl.style.cursor = "grabbing";
  window.addEventListener("mousemove", onCropDrag);
  window.addEventListener("mouseup", endCropDrag, { once:true });
});

function onCropDrag(ev){
  if(!cropDrag) return;
  const dx = ev.clientX - cropDrag.startMouse.x;
  const dy = ev.clientY - cropDrag.startMouse.y;
  state.crop.tx = cropDrag.start.tx + dx;
  state.crop.ty = cropDrag.start.ty + dy;
  applyCropTransform();
}
function endCropDrag(){
  window.removeEventListener("mousemove", onCropDrag);
  imgLayerEl.style.cursor = "grab";
  cropDrag = null;
  pushHistory();
}

/* ========= workspace pan (space drag) ========= */
let panning = false;
let panStart = { x:0, y:0, vx:0, vy:0 };
window.addEventListener("keydown", (ev)=>{
  if(ev.code === "Space"){
    // prevent page scroll
    ev.preventDefault();
  }
});
workspaceEl.addEventListener("mousedown", (ev)=>{
  // Space + drag pan
  if(isSpaceDown && ev.button === 0){
    panning = true;
    panStart = { x: ev.clientX, y: ev.clientY, vx: view.x, vy: view.y };
    window.addEventListener("mousemove", onPanMove);
    window.addEventListener("mouseup", endPan, { once:true });
  }
});
function onPanMove(ev){
  if(!panning) return;
  view.x = panStart.vx + (ev.clientX - panStart.x);
  view.y = panStart.vy + (ev.clientY - panStart.y);
  updateStageTransform();
}
function endPan(){
  window.removeEventListener("mousemove", onPanMove);
  panning = false;
}

/* ========= wheel zoom ========= */
workspaceEl.addEventListener("wheel", (ev)=>{
  // Ctrl+wheel => zoom view
  if(ev.ctrlKey){
    ev.preventDefault();
    const factor = ev.deltaY < 0 ? 1.08 : 1/1.08;
    zoomBy(factor, ev.clientX, ev.clientY);
    return;
  }
  // crop mode: Ctrl+wheel already used by view zoom, so for image zoom use Alt+wheel
  if(state.mode === "crop" && ev.altKey){
    ev.preventDefault();
    const factor = ev.deltaY < 0 ? 1.06 : 1/1.06;
    state.crop.s = Math.min(6, Math.max(0.2, state.crop.s * factor));
    applyCropTransform();
    pushHistory();
  }
}, { passive:false });

/* ========= keyboard shortcuts ========= */
let isSpaceDown = false;
window.addEventListener("keydown", (ev)=>{
  if(ev.code === "Space") isSpaceDown = true;

  // Undo/Redo
  if(ev.ctrlKey && !ev.shiftKey && ev.key.toLowerCase() === "z"){
    ev.preventDefault(); undo(); return;
  }
  if((ev.ctrlKey && ev.key.toLowerCase() === "y") || (ev.ctrlKey && ev.shiftKey && ev.key.toLowerCase() === "z")){
    ev.preventDefault(); redo(); return;
  }
  // Delete
  if(ev.key === "Delete"){
    ev.preventDefault();
    deleteSelected();
  }
  // Esc deselect
  if(ev.key === "Escape"){
    state.selectedId = null;
    renderHotspots();
    renderHotspotList();
  }
});
window.addEventListener("keyup", (ev)=>{
  if(ev.code === "Space") isSpaceDown = false;
});

/* ========= preview drawer ========= */
$("showHotspots").addEventListener("change", ()=> refreshPhonePreview());

function togglePreview(open){
  const overlay = $("drawerOverlay");
  const drawer = $("previewDrawer");
  if(open){
    overlay.classList.remove("hidden");
    drawer.classList.remove("translate-y-full");
    refreshPhonePreview();
  }else{
    overlay.classList.add("hidden");
    drawer.classList.add("translate-y-full");
  }
}
function refreshPhonePreview(){
  const img = $("phoneImg");
  const wrap = $("phoneHotspots");
  if(!state.imageUrl){
    img.src = "";
    wrap.innerHTML = "";
    return;
  }

  img.src = state.imageUrl;
  wrap.innerHTML = "";

  requestAnimationFrame(()=>{
    const show = $("showHotspots").checked;
    const r = wrap.getBoundingClientRect();
    if(!r.width || !r.height) return;

    state.hotspots.forEach((h, i)=>{
      if(show){
        const box = document.createElement("div");
        box.style.position = "absolute";
        box.style.left = (h.x * r.width) + "px";
        box.style.top = (h.y * r.height) + "px";
        box.style.width = (h.w * r.width) + "px";
        box.style.height = (h.h * r.height) + "px";
        box.style.border = "2px solid rgba(239,68,68,.9)";
        box.style.background = "rgba(239,68,68,.10)";
        box.style.borderRadius = "10px";
        wrap.appendChild(box);
      }

      const btn = document.createElement("button");
      btn.style.position = "absolute";
      btn.style.left = (h.x*100) + "%";
      btn.style.top = (h.y*100) + "%";
      btn.style.width = (h.w*100) + "%";
      btn.style.height = (h.h*100) + "%";
      btn.style.background = "transparent";
      btn.onclick = () => {
        const t = (h.text || "").trim();
        alert(`ç†±å€ ${i+1}\nå°‡é€å‡ºï¼š${t || "ï¼ˆå°šæœªå¡«ï¼‰"}`);
      };
      wrap.appendChild(btn);
    });
  });
}

/* ========= upload / compress ========= */
$("quality").addEventListener("input", () => $("qVal").textContent = $("quality").value);

async function compressImage(file, {maxSide, mime, quality, cropSquare}){
  const img = await createImageBitmap(file);

  let sx = 0, sy = 0, sw = img.width, sh = img.height;
  if(cropSquare){
    const side = Math.min(img.width, img.height);
    sx = Math.floor((img.width - side) / 2);
    sy = Math.floor((img.height - side) / 2);
    sw = side; sh = side;
  }

  const longSide = Math.max(sw, sh);
  const scale = Math.min(1, maxSide / longSide);
  const w = Math.max(1, Math.round(sw * scale));
  const h = Math.max(1, Math.round(sh * scale));

  const canvas = document.createElement("canvas");
  canvas.width = w; canvas.height = h;
  const ctx = canvas.getContext("2d", { alpha: true });
  ctx.drawImage(img, sx, sy, sw, sh, 0, 0, w, h);

  const outBlob = await new Promise((resolve) => canvas.toBlob(resolve, mime, quality));
  if(!outBlob) throw new Error("å£“ç¸®å¤±æ•—ï¼ˆtoBlob ç©ºï¼‰");

  const ext = (mime === "image/webp") ? "webp" : "jpg";
  const safeName = (file.name || "image").replace(/\.[^/.]+$/, "");
  return { blob: outBlob, filename: `${safeName}.${ext}` };
}

async function pickAndUpload(){
  const base = normalizeWorkerUrl(workerUrlEl.value);
  if(!base) return alert("è«‹å…ˆå¡« Worker URL");
  localStorage.setItem("line_worker_url", base);

  const input = $("fileInput");
  input.value = "";
  input.onchange = async (e)=>{
    const file = e.target.files[0];
    if(!file) return;

    try{
      setStatus("å£“ç¸®+ä¸Šå‚³ä¸­...");
      const maxSide = parseInt($("maxSide").value, 10);
      const mime = $("outFormat").value;
      const quality = parseFloat($("quality").value);
      const cropSquare = $("cropSquare").checked;

      const { blob, filename } = await compressImage(file, {maxSide, mime, quality, cropSquare});
      const url = await uploadToR2(base, blob, filename);

      // keep source for later crop-export
      state._sourceBlob = blob;
      state._sourceName = filename.replace(/\.[^/.]+$/, "");

      // reset crop
      state.crop = { tx:0, ty:0, s:1 };
      state.hotspots = [];
      state.selectedId = null;

      setImageUrl(url, true);
      applyCropTransform();
      pushHistory();
      renderAll();

      setStatus("ä¸Šå‚³å®Œæˆ âœ…ï¼ˆå¯è£åˆ‡ / ç•«æ¡†ï¼‰");
      fitToScreen();
      togglePreview(true);
    }catch(err){
      setStatus("ä¸Šå‚³å¤±æ•—");
      alert("ä¸Šå‚³å¤±æ•—ï¼š\n" + err.message);
    }
  };
  input.click();
}

/* ========= export crop (çœŸæ­£è£åˆ‡æˆåº•æ¡†å°ºå¯¸) =========
æŠŠç›®å‰è£åˆ‡è¦–è¦ºçµæœ -> canvas -> blob -> ä¸Šå‚³ -> æ›¿æ› imageUrl
*/
async function exportCropAndUpload(){
  const base = normalizeWorkerUrl(workerUrlEl.value);
  if(!base) return alert("è«‹å…ˆå¡« Worker URL");
  if(!state.imageUrl) return alert("ç›®å‰æ²’æœ‰åœ–ç‰‡");
  localStorage.setItem("line_worker_url", base);

  try{
    setStatus("ä¾è£åˆ‡è¼¸å‡ºä¸­...");

    // load image
    const im = await new Promise((resolve, reject)=>{
      const x = new Image();
      x.crossOrigin = "anonymous";
      x.onload = ()=> resolve(x);
      x.onerror = ()=> reject(new Error("åœ–ç‰‡è¼‰å…¥å¤±æ•—ï¼ˆå¯èƒ½ CORS / URL ä¸å¯ç”¨ï¼‰"));
      x.src = state.imageUrl;
    });

    // artboard px size
    const W = state.frame.w;
    const H = state.frame.h;

    // draw transformed image to canvas: we mimic CSS transform (center + translate + scale)
    const canvas = document.createElement("canvas");
    canvas.width = W;
    canvas.height = H;
    const ctx = canvas.getContext("2d");

    // background
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0,0,W,H);

    // compute draw size: we want image cover the artboard by default (like object-cover)
    // base cover scale to cover W/H
    const sCover = Math.max(W / im.naturalWidth, H / im.naturalHeight);
    const s = sCover * state.crop.s;

    const dw = im.naturalWidth * s;
    const dh = im.naturalHeight * s;

    // center
    const cx = W/2 + state.crop.tx;
    const cy = H/2 + state.crop.ty;

    const dx = cx - dw/2;
    const dy = cy - dh/2;

    ctx.drawImage(im, dx, dy, dw, dh);

    // encode
    const mime = $("outFormat").value;
    const quality = parseFloat($("quality").value);
    const outBlob = await new Promise(res=>{
      if(mime === "image/jpeg") canvas.toBlob(res, mime, quality);
      else canvas.toBlob(res, "image/webp", quality);
    });
    if(!outBlob) throw new Error("è¼¸å‡ºå¤±æ•—ï¼ˆtoBlob ç©ºï¼‰");

    const ext = (mime === "image/jpeg") ? "jpg" : "webp";
    const filename = (state._sourceName || "crop") + `_crop_${W}x${H}.${ext}`;

    const url = await uploadToR2(base, outBlob, filename);

    // replace imageUrl to cropped result, and reset crop offsets (already baked)
    state.imageUrl = url;
    state.crop = { tx:0, ty:0, s:1 };
    imgEl.src = url;
    applyCropTransform();

    pushHistory();
    renderAll();
    setStatus("è£åˆ‡è¼¸å‡ºå®Œæˆ âœ…ï¼ˆå·²æ›æˆåº•æ¡†å°ºå¯¸çš„åœ–ç‰‡ï¼‰");
    togglePreview(true);
  }catch(err){
    setStatus("è£åˆ‡è¼¸å‡ºå¤±æ•—");
    alert("è£åˆ‡è¼¸å‡ºå¤±æ•—ï¼š\n" + err.message);
  }
}

/* ========= clear ========= */
function clearAll(){
  if(!confirm("ç¢ºå®šæ¸…ç©ºåœ–ç‰‡ + å…¨éƒ¨ç†±å€ï¼Ÿ")) return;
  state.imageUrl = "";
  state.hotspots = [];
  state.selectedId = null;
  state.crop = { tx:0, ty:0, s:1 };
  imgEl.src = "";
  pushHistory();
  renderAll();
}

/* ========= build imagemap message ========= */
async function buildImagemapMessage(){
  if(!state.imageUrl) throw new Error("å°šæœªæœ‰åœ–ç‰‡");
  if(state.hotspots.length === 0) throw new Error("å°šæœªæ–°å¢ç†±å€");
  if(state.hotspots.some(h => !String(h.text||"").trim())) throw new Error("æœ‰ç†±å€æ²’æœ‰å¡«å…§å®¹");

  const baseW = 1040;
  const baseH = state.frame.h; // 1040/1560/2080

  const actions = state.hotspots.map(h => ({
    type: "message",
    text: h.text.trim(),
    area: {
      x: Math.round(h.x * baseW),
      y: Math.round(h.y * baseH),
      width: Math.round(h.w * baseW),
      height: Math.round(h.h * baseH)
    }
  }));

  return {
    type: "imagemap",
    baseUrl: state.imageUrl,
    altText: "è«‹é»é¸",
    baseSize: { width: baseW, height: baseH },
    actions
  };
}

/* ========= save/load =========
æ³¨æ„ï¼šä½ èªªä¸è¦å¯†ç¢¼ï¼Œæ‰€ä»¥é€™è£¡é€çš„ JSON ä¸å¸¶ password
ï¼ˆä½ çš„ worker.js ä¹Ÿè¦é…åˆå–æ¶ˆ password åˆ¤æ–·ï¼‰
*/
async function saveConfig(){
  const base = normalizeWorkerUrl(workerUrlEl.value);
  const keyword = triggerEl.value.trim();
  const name = fileNameEl.value.trim();

  if(!base || !keyword) return alert("è«‹å¡« Worker URL + è§¸ç™¼é—œéµå­—");
  localStorage.setItem("line_worker_url", base);

  try{
    state.triggerKeyword = keyword;
    state.meta.name = name;

    const msg = await buildImagemapMessage();
    const payload = {
      mode: "imagemap",
      meta: { name: state.meta.name || "" },
      messages: [msg]
    };

    // worker: POST /save { keyword, payload }
    await postJSON(base + "/save", { keyword, payload });

    pushHistory();
    setStatus("å„²å­˜æˆåŠŸ âœ…");
    alert("å„²å­˜æˆåŠŸï¼\nä½¿ç”¨è€…è¼¸å…¥è§¸ç™¼é—œéµå­—ï¼šã€Œ" + keyword + "ã€å°±æœƒå‡ºç¾é€™å¼µåœ–ã€‚");
  }catch(e){
    setStatus("å„²å­˜å¤±æ•—");
    alert("å„²å­˜å¤±æ•—ï¼š\n" + e.message);
  }
}

async function loadConfig(){
  const base = normalizeWorkerUrl(workerUrlEl.value);
  const keyword = triggerEl.value.trim();
  if(!base || !keyword) return alert("è«‹å¡« Worker URL + è§¸ç™¼é—œéµå­—");
  localStorage.setItem("line_worker_url", base);

  try{
    const data = await postJSON(base + "/load", { keyword });
    const obj = (typeof data === "string") ? JSON.parse(data) : data;

    if(obj.mode !== "imagemap" || !obj.messages?.[0]) throw new Error("ä¸æ˜¯ imagemap æ ¼å¼");
    const m = obj.messages[0];

    state.meta = obj.meta || { name:"" };
    state.triggerKeyword = keyword;
    state.imageUrl = m.baseUrl || "";
    state.frame = {
      w: (m.baseSize?.width || 1040),
      h: (m.baseSize?.height || 1040)
    };

    // normalize from baseSize
    const bw = state.frame.w || 1040;
    const bh = state.frame.h || 1040;

    state.hotspots = (m.actions || []).map((a, idx)=>({
      id: uid(),
      x: (a.area?.x || 0) / bw,
      y: (a.area?.y || 0) / bh,
      w: (a.area?.width || 0) / bw,
      h: (a.area?.height || 0) / bh,
      text: a.text || ""
    }));
    state.selectedId = state.hotspots[0]?.id || null;

    // reset crop (already baked on image)
    state.crop = { tx:0, ty:0, s:1 };

    // UI
    fileNameEl.value = (state.meta?.name || "");
    $("framePreset").value = (state.frame.h / state.frame.w).toString();
    applyFramePreset(true);

    setImageUrl(state.imageUrl, true);
    applyCropTransform();

    pushHistory();
    renderAll();
    fitToScreen();
    togglePreview(true);

    setStatus("è®€å–æˆåŠŸ âœ…");
  }catch(e){
    setStatus("è®€å–å¤±æ•—");
    alert("è®€å–å¤±æ•—ï¼š\n" + e.message);
  }
}

/* ========= LIFF send test ========= */
async function sendTestToMe(){
  if(!isReady) return alert("LIFF å°šæœªåˆå§‹åŒ–å®Œæˆ");
  if(!liff.isInClient()) return alert("è«‹åœ¨ LINE å…§é–‹å•Ÿï¼ˆå½ˆçª—ï¼‰æ‰å¯é€æ¸¬è©¦è¨Šæ¯");

  try{
    const msg = await buildImagemapMessage();
    await liff.sendMessages([msg]);
    alert("å·²æŠŠ imagemap é€åˆ°ä½ ç›®å‰çš„èŠå¤©å®¤ âœ…\nä½ å¯ä»¥ç›´æ¥é»ç†±å€æ¸¬è©¦æ˜¯å¦æœƒé€å‡ºé—œéµå­—ã€‚");
  }catch(e){
    alert("é€æ¸¬è©¦å¤±æ•—ï¼š\n" + e.message);
  }
}
async function sendPreviewToMe(){ return sendTestToMe(); }

/* ========= close ========= */
function closeLiff(){
  if(window.liff && liff.isInClient()) liff.closeWindow();
  else window.close();
}

/* ========= init LIFF ========= */
async function initLIFF(){
  try{
    liffStateEl.textContent = "åˆå§‹åŒ–ä¸­...";
    await liff.init({ liffId: LIFF_ID });

    if(!liff.isLoggedIn()){
      liffStateEl.textContent = "éœ€è¦ç™»å…¥";
      liff.login();
      return;
    }

    liffStateEl.textContent = liff.isInClient() ? "LINE å…§ï¼ˆå½ˆçª—ï¼‰" : "å¤–éƒ¨ç€è¦½å™¨";
    const p = await liff.getProfile();
    userNameEl.textContent = p.displayName || "-";

    const savedUrl = localStorage.getItem("line_worker_url");
    if(savedUrl) workerUrlEl.value = savedUrl;

    // default artboard
    applyFramePreset(true);

    // initial history
    pushHistory();
    renderModeBadge();
    fitToScreen();

    isReady = true;
    setStatus("å°±ç·’ âœ…ï¼ˆå¯ä¸Šå‚³ã€è£åˆ‡ã€ç•«æ¡†ã€å„²å­˜ï¼‰");
  }catch(e){
    liffStateEl.textContent = "åˆå§‹åŒ–å¤±æ•—";
    setStatus("åˆå§‹åŒ–å¤±æ•—");
    alert("LIFF åˆå§‹åŒ–å¤±æ•—ï¼š\n" + e.message + "\n\nè«‹ç¢ºèª LIFF_ID æ­£ç¢ºã€‚");
  }
}

/* ========= input sync ========= */
triggerEl.addEventListener("input", ()=> {
  state.triggerKeyword = triggerEl.value.trim();
});
fileNameEl.addEventListener("input", ()=> {
  state.meta.name = fileNameEl.value;
});

/* ========= start ========= */
imgEl.addEventListener("load", ()=>{
  applyCropTransform();
  refreshPhonePreview();
});
initLIFF();
</script>

</body>
</html>
