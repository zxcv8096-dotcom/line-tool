// worker.js - KV + R2 + LINE webhook + RichMenu 套用
// Bindings: DB (KV), REPLIES (KV optional), BUCKET (R2)
// Secrets: CHANNEL_ACCESS_TOKEN (必), CHANNEL_SECRET (選)

export default {
  async fetch(request, env) {
    const url = new URL(request.url);

    const corsHeaders = {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "POST, GET, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type",
    };

    if (request.method === "OPTIONS") {
      return new Response(null, { status: 204, headers: corsHeaders });
    }

    const json = (obj, status = 200) =>
      new Response(JSON.stringify(obj), {
        status,
        headers: { ...corsHeaders, "Content-Type": "application/json; charset=utf-8" },
      });

    try {
      if (url.pathname === "/health" && request.method === "GET") {
        return json({ ok: true, ts: Date.now() }, 200);
      }

      // ===== R2 upload =====
      if (url.pathname === "/upload" && request.method === "POST") {
        if (!env.BUCKET) return json({ ok: false, error: "R2(BUCKET) 未綁定" }, 500);

        let form;
        try { form = await request.formData(); }
        catch { return json({ ok: false, error: "請用 multipart/form-data 上傳" }, 400); }

        const file = form.get("file");
        if (!file || typeof file === "string") {
          return json({ ok: false, error: "缺少檔案欄位 file" }, 400);
        }

        // content-type 不可靠，用副檔名/預設
        let contentType = (file.type || "").toLowerCase();
        const extGuess = guessExtFromType(contentType) || guessExtFromName(file.name) || "jpg";
        if (!contentType.startsWith("image/")) {
          contentType = extGuess === "png" ? "image/png" : "image/jpeg";
        }

        if (!(contentType.includes("png") || contentType.includes("jpeg") || contentType.includes("jpg"))) {
          return json({ ok: false, error: "只允許 PNG / JPEG" }, 400);
        }

        const ext = contentType.includes("png") ? "png" : "jpg";
        const key = `uploads/${Date.now()}-${crypto.randomUUID()}.${ext}`;

        await env.BUCKET.put(key, file.stream(), {
          httpMetadata: { contentType, cacheControl: "public, max-age=31536000, immutable" },
          customMetadata: { originalName: (file.name || "").slice(0, 200) },
        });

        const publicUrl = `${url.origin}/file/${encodeURIComponent(key)}`;
        return json({ ok: true, key, url: publicUrl }, 200);
      }

      // ===== R2 file =====
      if (url.pathname.startsWith("/file/") && request.method === "GET") {
        if (!env.BUCKET) return json({ ok: false, error: "R2(BUCKET) 未綁定" }, 500);

        const key = decodeURIComponent(url.pathname.replace("/file/", ""));
        if (!key) return new Response("Not Found", { status: 404, headers: corsHeaders });

        const obj = await env.BUCKET.get(key);
        if (!obj) return new Response("Not Found", { status: 404, headers: corsHeaders });

        const headers = new Headers();
        obj.writeHttpMetadata(headers);
        headers.set("ETag", obj.etag);
        headers.set("Access-Control-Allow-Origin", "*");
        headers.set("Cache-Control", "public, max-age=31536000, immutable");

        let ct = (headers.get("content-type") || "").toLowerCase();
        if (!ct.startsWith("image/")) {
          const ext = guessExtFromName(key) || "";
          ct = ext === "png" ? "image/png" : "image/jpeg";
          headers.set("content-type", ct);
        }

        return new Response(obj.body, { status: 200, headers });
      }

      // =========================================================
      // RichMenu save/load/list
      // =========================================================
      if (url.pathname === "/richmenu/save" && request.method === "POST") {
        if (!env.DB) return json({ ok: false, error: "KV(DB) 未綁定" }, 500);
        if (!env.BUCKET) return json({ ok: false, error: "R2(BUCKET) 未綁定" }, 500);
        if (!env.CHANNEL_ACCESS_TOKEN) return json({ ok:false, error:"缺少 CHANNEL_ACCESS_TOKEN" }, 500);

        const data = await request.json().catch(() => ({}));
        const name = String(data?.name || "").trim();
        const payload = data?.payload;
        const isDefault = !!data?.isDefault;

        if (!name) return json({ ok: false, error: "name 不可空白" }, 400);
        if (!payload) return json({ ok: false, error: "payload 不可空白" }, 400);

        const fixed = ensureMeta(payload, { feature: "richmenu", createdFrom: "tool_richmenu", status: "active" });
        await env.DB.put(`RM:${name}`, JSON.stringify(fixed));
        if (isDefault) await env.DB.put("RM:__DEFAULT__", JSON.stringify({ name }));

        // 建立 RichMenu
        const rmBody = {
          size: fixed.size,
          selected: true,
          name,
          chatBarText: (name || "選單").slice(0, 14),
          areas: fixed.areas || [],
        };

        // 刪同名舊 ID
        const idKey = `RMID:${name}`;
        const oldId = await env.DB.get(idKey);
        if (oldId) { try { await lineDelete(env, `/v2/bot/richmenu/${encodeURIComponent(oldId)}`); } catch {} }

        const created = await linePost(env, "/v2/bot/richmenu", rmBody);
        const richMenuId = created?.richMenuId;
        if (!richMenuId) throw new Error("LINE 建立 richmenu 失敗（沒有 richMenuId）");

        // ✅ 取 imageKey（沒有就從 imageUrl 推）
        let imageKey = String(fixed.imageKey || "").trim();
        if (!imageKey) {
          const imageUrl = String(fixed.imageUrl || "").trim();
          try {
            const u = new URL(imageUrl);
            if (u.pathname.startsWith("/file/")) imageKey = decodeURIComponent(u.pathname.replace("/file/", ""));
          } catch {}
        }
        if (!imageKey) throw new Error("缺少 imageKey（請重新匯入圖片）");

        const obj = await env.BUCKET.get(imageKey);
        if (!obj) throw new Error(`圖片讀取失敗 404（R2 key 不存在）：${imageKey}`);

        const buf = await obj.arrayBuffer();
        const ct = sniffImageType(buf);
        if (!ct) throw new Error("LINE RichMenu 只支援 PNG/JPEG（檔頭不是 PNG/JPEG）");

        // 上傳圖片到 LINE
        const up = await fetch(`https://api-data.line.me/v2/bot/richmenu/${encodeURIComponent(richMenuId)}/content`, {
          method: "POST",
          headers: { Authorization: `Bearer ${env.CHANNEL_ACCESS_TOKEN}`, "Content-Type": ct },
          body: buf,
        });
        if (!up.ok) throw new Error(`LINE 上傳圖片失敗 ${up.status}: ${await up.text().catch(()=> "")}`);

        // 套用預設
        if (isDefault) await linePost(env, `/v2/bot/user/all/richmenu/${encodeURIComponent(richMenuId)}`, null);

        await env.DB.put(idKey, richMenuId);
        return json({ ok: true, richMenuId, isDefault }, 200);
      }

      if (url.pathname === "/richmenu/load" && request.method === "POST") {
        if (!env.DB) return json({ ok: false, error: "KV(DB) 未綁定" }, 500);

        const data = await request.json().catch(() => ({}));
        const name = String(data?.name || "").trim();
        if (!name) return json({ ok: false, error: "name 不可空白" }, 400);

        const raw = await env.DB.get(`RM:${name}`);
        if (!raw) return json({ ok: false, error: "無資料" }, 404);

        const defRaw = await env.DB.get("RM:__DEFAULT__");
        let isDefault = false;
        try { isDefault = (defRaw ? JSON.parse(defRaw).name : "") === name; } catch {}

        try { return json({ ok: true, payload: JSON.parse(raw), isDefault }, 200); }
        catch { return json({ ok: true, payload: raw, isDefault }, 200); }
      }

      if (url.pathname === "/richmenu/list" && request.method === "POST") {
        if (!env.DB) return json({ ok: false, error: "KV(DB) 未綁定" }, 500);

        const list = await env.DB.list({ limit: 1000 });
        const keys = (list.keys || []).map(k => k.name).filter(n => n.startsWith("RM:") && n !== "RM:__DEFAULT__");

        const defRaw = await env.DB.get("RM:__DEFAULT__");
        let defName = "";
        try { defName = defRaw ? JSON.parse(defRaw).name : ""; } catch {}

        const items = keys
          .map(k => ({ name: k.replace(/^RM:/, ""), isDefault: k.replace(/^RM:/,"") === defName }))
          .sort((a,b)=>a.name.localeCompare(b.name, "zh-Hant"));

        return json({ ok: true, items }, 200);
      }

      // =========================================================
      // LINE webhook（有 x-line-signature 才當 webhook）
      // =========================================================
      const hasLineSig = !!request.headers.get("x-line-signature");
      if (request.method === "POST" && hasLineSig) {
        const signature = request.headers.get("x-line-signature") || "";
        const raw = await request.text();

        if (env.CHANNEL_SECRET) {
          const ok = await verifyLineSignature(raw, signature, env.CHANNEL_SECRET);
          if (!ok) return json({ ok: false, error: "Invalid signature" }, 401);
        }

        let body;
        try { body = JSON.parse(raw); }
        catch { return json({ ok: false, error: "Webhook body 不是 JSON" }, 400); }

        if (body && Array.isArray(body.events)) {
          for (const event of body.events) {
            if (event?.type === "message" && event?.message?.type === "text") {
              await handleMessage(event, env);
            }
          }
        }
        return json({ ok: true }, 200);
      }

      return json({ ok: true, message: "API Running (KV + R2 + RichMenu + Webhook)" }, 200);

    } catch (e) {
      return json({ ok: false, error: "Server Error", detail: String(e?.message || e) }, 500);
    }
  },
};

// ===== helpers =====
function guessExtFromType(type) {
  const map = { "image/jpeg":"jpg","image/jpg":"jpg","image/png":"png","image/webp":"webp","image/gif":"gif","image/avif":"avif","image/svg+xml":"svg" };
  return map[type] || null;
}
function guessExtFromName(name) {
  const m = (name || "").toLowerCase().match(/\.([a-z0-9]+)$/);
  if (!m) return null;
  const ext = m[1];
  return ["jpg","jpeg","png","webp","gif","avif","svg"].includes(ext) ? (ext === "jpeg" ? "jpg" : ext) : null;
}
function ensureMeta(payload, defaults = {}) {
  const obj = payload && typeof payload === "object" ? payload : { value: payload };
  obj.meta = obj.meta && typeof obj.meta === "object" ? obj.meta : {};
  if (!obj.meta.feature) obj.meta.feature = defaults.feature || "unknown";
  if (!obj.meta.status) obj.meta.status = defaults.status || "active";
  if (!obj.meta.createdFrom) obj.meta.createdFrom = defaults.createdFrom || "unknown";
  if (typeof obj.meta.note !== "string") obj.meta.note = "";
  obj.meta.updatedAt = Date.now();
  return obj;
}
function sniffImageType(buf) {
  const u = new Uint8Array(buf);
  if (u.length >= 8 && u[0]===0x89 && u[1]===0x50 && u[2]===0x4E && u[3]===0x47 && u[4]===0x0D && u[5]===0x0A && u[6]===0x1A && u[7]===0x0A) return "image/png";
  if (u.length >= 3 && u[0]===0xFF && u[1]===0xD8 && u[2]===0xFF) return "image/jpeg";
  return "";
}

// LINE signature verify
async function verifyLineSignature(rawBody, signature, channelSecret) {
  try {
    const enc = new TextEncoder();
    const key = await crypto.subtle.importKey("raw", enc.encode(channelSecret), { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
    const mac = await crypto.subtle.sign("HMAC", key, enc.encode(rawBody));
    const b64 = arrayBufferToBase64(mac);
    return safeEqual(b64, signature);
  } catch { return false; }
}
function arrayBufferToBase64(buf) {
  const bytes = new Uint8Array(buf);
  let binary = "";
  for (let i=0;i<bytes.byteLength;i++) binary += String.fromCharCode(bytes[i]);
  return btoa(binary);
}
function safeEqual(a, b) {
  if (typeof a !== "string" || typeof b !== "string") return false;
  if (a.length !== b.length) return false;
  let out = 0;
  for (let i=0;i<a.length;i++) out |= a.charCodeAt(i) ^ b.charCodeAt(i);
  return out === 0;
}

// LINE helpers
async function linePost(env, path, body = null) {
  const res = await fetch("https://api.line.me" + path, {
    method: "POST",
    headers: {
      Authorization: `Bearer ${env.CHANNEL_ACCESS_TOKEN}`,
      ...(body ? { "Content-Type": "application/json" } : {}),
    },
    body: body ? JSON.stringify(body) : null,
  });
  const txt = await res.text().catch(() => "");
  if (!res.ok) throw new Error(`LINE API ${res.status}: ${txt}`);
  try { return JSON.parse(txt); } catch { return txt; }
}
async function lineDelete(env, path) {
  const res = await fetch("https://api.line.me" + path, { method: "DELETE", headers: { Authorization: `Bearer ${env.CHANNEL_ACCESS_TOKEN}` } });
  const txt = await res.text().catch(() => "");
  if (!res.ok) throw new Error(`LINE API ${res.status}: ${txt}`);
  return true;
}

// QuickReply/messages reply
async function handleMessage(event, env) {
  if (!env.DB) return;
  if (!env.CHANNEL_ACCESS_TOKEN) return;

  const userText = (event.message.text || "").trim();
  if (!userText) return;

  const stored = await env.DB.get(userText);
  if (!stored) return;

  let config;
  try { config = JSON.parse(stored); } catch { return; }

  let messages = [];
  if (config.mode === "text") {
    const msg = { type: "text", text: config.replyText || "請選擇：" };
    if (Array.isArray(config.quickReplies) && config.quickReplies.length > 0) {
      msg.quickReply = {
        items: config.quickReplies.slice(0, 13).map((b) => ({
          type: "action",
          action: {
            type: "message",
            label: String(b.label || "").slice(0, 20) || "選項",
            text: String(b.text || "").slice(0, 300),
          },
        })),
      };
    }
    messages = [msg];
  } else if (Array.isArray(config.messages) && config.messages.length > 0) {
    messages = config.messages;
  } else {
    return;
  }

  await fetch("https://api.line.me/v2/bot/message/reply", {
    method: "POST",
    headers: { "Content-Type": "application/json", Authorization: `Bearer ${env.CHANNEL_ACCESS_TOKEN}` },
    body: JSON.stringify({ replyToken: event.replyToken, messages }),
  });
}
