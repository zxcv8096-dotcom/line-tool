<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>å…­å®®æ ¼é¸å–®</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root{
      --rail-w: 168px;
      --panel-w: 360px;
      --preview-w: 360px;
    }
    body{ user-select:none; }
    input, textarea, select, button { user-select:auto; }

    /* å·¥ä½œå€æ£‹ç›¤èƒŒæ™¯ */
    .checker{
      background-image:
        linear-gradient(45deg, rgba(0,0,0,.04) 25%, transparent 25%),
        linear-gradient(-45deg, rgba(0,0,0,.04) 25%, transparent 25%),
        linear-gradient(45deg, transparent 75%, rgba(0,0,0,.04) 75%),
        linear-gradient(-45deg, transparent 75%, rgba(0,0,0,.04) 75%);
      background-size: 28px 28px;
      background-position: 0 0, 0 14px, 14px -14px, -14px 0px;
    }

    /* Artboardï¼ˆRich Menu å°ºå¯¸å›ºå®š 2500Ã—1686ï¼‰ */
    .artboard{
      position:absolute;
      left:50%; top:50%;
      transform: translate(-50%, -50%);
      background:#fff;
      border:1px solid rgba(15,23,42,.18);
      box-shadow: 0 12px 30px rgba(0,0,0,.12);
      border-radius: 14px;
      overflow:hidden;
    }

    /* åœ–ç‰‡å±¤ï¼ˆè£åˆ‡æ™‚æ‹–å‹•ï¼‰ */
    .img-layer{
      position:absolute; inset:0;
      overflow:hidden;
      background:#f8fafc;
    }
    .img-layer.crop{ cursor: grab; }
    .img-layer.crop:active{ cursor: grabbing; }

    .img-layer img{
      position:absolute;
      left:50%; top:50%;
      transform-origin: center center;
      max-width:none;
      max-height:none;
      pointer-events:none;
      user-select:none;
    }

    /* ç†±å€æ¡† */
    .hotspot{
      position:absolute;
      border:2px solid rgba(239,68,68,.95);
      background: rgba(239,68,68,.18);
      border-radius: 10px;
      color:white;
      font-weight:800;
      font-size:12px;
      display:flex;
      align-items:center;
      justify-content:center;
      text-shadow:0 1px 2px rgba(0,0,0,.85);
      cursor:pointer;
      box-sizing: border-box;
    }
    .hotspot.selected{
      border-color: rgba(59,130,246,.95);
      background: rgba(59,130,246,.16);
    }

    /* æ‹‰è§’ handle */
    .handle{
      position:absolute;
      width:12px; height:12px;
      background:#fff;
      border:2px solid rgba(59,130,246,.95);
      border-radius: 4px;
      box-shadow:0 1px 3px rgba(0,0,0,.25);
      z-index: 10;
      box-sizing: border-box;
    }
    .handle.nw{ left:-7px; top:-7px; cursor:nwse-resize; }
    .handle.ne{ right:-7px; top:-7px; cursor:nesw-resize; }
    .handle.sw{ left:-7px; bottom:-7px; cursor:nesw-resize; }
    .handle.se{ right:-7px; bottom:-7px; cursor:nwse-resize; }

    /* æ‹–æ›³æ–°æ¡†é è¦½ */
    .draw-rect{
      position:absolute;
      border:2px dashed rgba(2,6,23,.55);
      background: rgba(2,6,23,.10);
      border-radius: 10px;
      pointer-events:none;
      box-sizing: border-box;
    }

    /* é è¦½å³å´ï¼ˆå¯æ”¶åˆï¼‰ */
    .preview-collapsed{
      width: 44px !important;
    }
  </style>
</head>

<body class="bg-slate-100 text-slate-800 overflow-hidden">

<!-- Top bar -->
<div class="h-14 bg-white border-b flex items-center justify-between px-3">
  <div class="flex items-center gap-3">
    <div class="font-extrabold text-blue-700 text-lg">å…­å®®æ ¼é¸å–®</div>
    <div class="hidden md:flex items-center gap-2 text-xs text-slate-500">
      <span>Ctrl+æ»¾è¼ªï¼šç¸®æ”¾ç•«é¢</span>
      <span>ï½œ</span>
      <span>ç©ºç™½éµæ‹–æ›³ï¼šå¹³ç§»</span>
      <span>ï½œ</span>
      <span>Ctrl+Z / Ctrl+Yï¼šå¾©åŸ / é‡åš</span>
      <span>ï½œ</span>
      <span>Deleteï¼šåˆªé™¤é¸å–æ¡†</span>
    </div>
  </div>
  <div class="flex items-center gap-2">
    <button class="px-3 py-2 rounded bg-slate-700 text-white text-sm hover:bg-slate-900" onclick="fitToScreen()">Fit</button>
  </div>
</div>

<!-- Main -->
<div class="h-[calc(100vh-56px)] flex">

  <!-- Left rail (æœ‰åç¨±) -->
  <div id="rail" class="w-[168px] bg-white border-r p-3 space-y-2">
    <button class="w-full px-3 py-2 rounded-xl bg-slate-900 text-white hover:bg-black flex items-center justify-between"
            onclick="togglePanel()">
      <span class="font-bold">å·¥å…·</span>
      <span>â˜°</span>
    </button>

    <div class="space-y-2">
      <button class="w-full px-3 py-2 rounded-xl bg-slate-100 hover:bg-slate-200 flex items-center justify-between"
              onclick="setMode('hotspot')">
        <span class="font-bold">ç•«æ¡†</span><span>ğŸ”²</span>
      </button>

      <button class="w-full px-3 py-2 rounded-xl bg-slate-100 hover:bg-slate-200 flex items-center justify-between"
              onclick="setMode('crop')">
        <span class="font-bold">è£åˆ‡</span><span>âœ‚ï¸</span>
      </button>

      <button class="w-full px-3 py-2 rounded-xl bg-slate-100 hover:bg-slate-200 flex items-center justify-between"
              onclick="resetView()">
        <span class="font-bold">é‡ç½®è¦–è§’</span><span>ğŸ”</span>
      </button>

      <button class="w-full px-3 py-2 rounded-xl bg-slate-100 hover:bg-slate-200 flex items-center justify-between"
              onclick="clearAll()">
        <span class="font-bold text-red-700">æ¸…ç©º</span><span>ğŸ§¹</span>
      </button>
    </div>

    <div class="pt-2 border-t text-xs text-slate-500">
      ç‹€æ…‹ï¼š<span id="statusText" class="font-bold text-slate-700">å°±ç·’</span>
    </div>
  </div>

  <!-- Left panel -->
  <div id="panel" class="w-[360px] bg-white border-r overflow-y-auto">
    <div class="p-4 space-y-4">

      <div class="rounded-xl border p-3 bg-slate-50">
        <div class="font-bold text-sm mb-2">åŸºæœ¬è¨­å®š</div>

        <label class="text-xs text-slate-500">Worker URLï¼ˆå¾é¦–é è‡ªå‹•å¸¶å…¥ï¼‰</label>
        <input id="workerUrl" class="mt-1 w-full border rounded px-3 py-2 bg-yellow-50 text-sm"
               placeholder="https://api.xxx.workers.dev" />

        <div class="grid grid-cols-2 gap-2 mt-2">
          <div>
            <label class="text-xs text-slate-500">è§¸ç™¼é—œéµå­—</label>
            <input id="triggerKeyword" class="mt-1 w-full border rounded px-3 py-2 text-sm font-bold border-blue-500"
                   placeholder="ä¾‹å¦‚ï¼šMENU_MAIN" />
          </div>
          <div>
            <label class="text-xs text-slate-500">æª”æ¡ˆåç¨±ï¼ˆä¹Ÿç•¶ä½œé¸å–®åç¨±ï¼‰</label>
            <input id="fileName" class="mt-1 w-full border rounded px-3 py-2 text-sm font-bold"
                   placeholder="ä¾‹å¦‚ï¼š2026-02 å…­å®®æ ¼ä¸»é¸å–®" />
          </div>
        </div>
      </div>

      <div class="rounded-xl border p-3">
        <div class="font-bold text-sm mb-2">åœ–ç‰‡</div>

        <div class="text-xs text-slate-500 mb-2">
          åŒ¯å…¥å¾Œæœƒè‡ªå‹•ä»¥ <b>2500Ã—1686</b> ä½œç‚ºåº•æ¡†ï¼ˆRich Menu å°ºå¯¸ï¼‰ã€‚
        </div>

        <div class="flex gap-2">
          <button id="btnImport"
                  class="flex-1 px-3 py-2 rounded bg-blue-600 text-white text-sm hover:bg-blue-700"
                  onclick="pickAndUpload()">
            åŒ¯å…¥åœ–ç‰‡
          </button>

          <button class="px-3 py-2 rounded bg-slate-900 text-white text-sm hover:bg-black"
                  onclick="exportCropAndUpload()">
            è¼¸å‡ºä¸Šå‚³
          </button>
        </div>

        <div class="mt-2 text-xs text-slate-500">
          è£åˆ‡æ¨¡å¼ä¸‹ï¼šæ‹–åœ–ç‰‡ç§»å‹•ï¼›<b>Alt + æ»¾è¼ª</b> æ”¾å¤§ç¸®å°åœ–ç‰‡ï¼ˆä¹Ÿå¯ Ctrl+Z/ Ctrl+Yï¼‰ã€‚
        </div>
      </div>

      <div class="rounded-xl border p-3">
        <div class="font-bold text-sm mb-2 flex items-center justify-between">
          <span>ç†±å€æ¸…å–®</span>
          <span id="hsCount" class="text-xs text-slate-500">0</span>
        </div>

        <div id="areaEmpty" class="text-xs text-slate-400">å°šæœªæ–°å¢ç†±å€</div>
        <div id="areaList" class="space-y-2"></div>

        <div class="mt-3 grid grid-cols-2 gap-2">
          <button class="px-3 py-2 rounded bg-gray-600 text-white text-sm hover:bg-gray-700" onclick="loadConfig()">è®€å–</button>
          <button class="px-3 py-2 rounded bg-green-600 text-white text-sm hover:bg-green-700" onclick="saveConfig()">å„²å­˜</button>
        </div>
      </div>

      <div class="text-xs text-slate-400 pb-10">
        * Ctrl+Z / Ctrl+Y å¯å¾©åŸ/é‡åšæ‰€æœ‰æ“ä½œï¼ˆç•«æ¡† / æ–‡å­— / è£åˆ‡ / åˆªé™¤ / åŒ¯å…¥ / è¼¸å‡ºï¼‰ã€‚
      </div>
    </div>
  </div>

  <!-- Workspace -->
  <div class="flex-1 relative checker overflow-hidden" id="workspace">

    <!-- zoom HUD -->
    <div class="absolute top-3 right-3 z-20 flex items-center gap-2 bg-white/90 backdrop-blur border rounded-xl px-2 py-1 shadow">
      <button class="px-2 py-1 rounded hover:bg-slate-100 text-sm" onclick="zoomBy(1.1)">ï¼‹</button>
      <div class="w-16 text-center text-sm font-bold" id="zoomLabel">100%</div>
      <button class="px-2 py-1 rounded hover:bg-slate-100 text-sm" onclick="zoomBy(1/1.1)">ï¼</button>
    </div>

    <!-- stage (pan/zoom transform) -->
    <div id="stage" class="absolute inset-0">

      <div id="artboard" class="artboard">
        <div id="imgLayer" class="img-layer">
          <img id="img" alt="">
          <!-- safety overlay -->
          <div id="safety" class="absolute inset-0 pointer-events-none"></div>
        </div>

        <div id="hotspotLayer" class="absolute inset-0"></div>
        <div id="drawLayer" class="absolute inset-0"></div>
      </div>

    </div>
  </div>

  <!-- Right preview (auto show + collapsible) -->
  <div id="previewPanel" class="w-[360px] bg-white border-l relative transition-all duration-200">
    <button class="absolute -left-4 top-6 w-8 h-10 rounded-l-xl bg-slate-900 text-white shadow hover:bg-black"
            onclick="togglePreviewPanel()"
            title="æ”¶åˆ/å±•é–‹é è¦½">
      â‡„
    </button>

    <div id="previewInner" class="h-full p-4">
      <div class="font-bold text-sm mb-2">é è¦½</div>

      <div class="mx-auto w-[320px] max-w-full">
        <div class="rounded-[22px] border-4 border-slate-900 bg-slate-900 p-2">
          <div class="rounded-[16px] bg-white overflow-hidden">
            <div class="bg-slate-100 text-xs text-slate-600 px-3 py-2 border-b">Rich Menu é è¦½</div>
            <div class="p-2">
              <div class="relative rounded-lg overflow-hidden border bg-white">
                <img id="previewImg" class="w-full h-[210px] object-cover bg-gray-100" alt="">
                <div id="previewHotspots" class="absolute inset-0"></div>
              </div>
              <div class="mt-2 text-[11px] text-slate-500">
                ç·¨è¼¯æ™‚è‡ªå‹•æ›´æ–°ï¼ˆä¸ç”¨æŒ‰é è¦½ï¼‰
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="mt-4 text-xs text-slate-500">
        é»ç´…æ¡†å¯æŸ¥çœ‹é€å‡ºæ–‡å­—ï¼ˆæ¨¡æ“¬é»é¸ï¼‰
      </div>
    </div>
  </div>

</div>

<input type="file" id="fileInput" accept="image/*" hidden>

<script>
/* ===================== å›ºå®š Rich Menu å°ºå¯¸ ===================== */
const FRAME_W = 2500;
const FRAME_H = 1686;
/* =============================================================== */

const $ = (id) => document.getElementById(id);

const workerUrlEl = $("workerUrl");
const triggerEl = $("triggerKeyword");
const fileNameEl = $("fileName");

const statusTextEl = $("statusText");
const panelEl = $("panel");
const workspaceEl = $("workspace");
const stageEl = $("stage");
const artboardEl = $("artboard");
const imgLayerEl = $("imgLayer");
const imgEl = $("img");
const safetyEl = $("safety");

const hotspotLayerEl = $("hotspotLayer");
const drawLayerEl = $("drawLayer");
const areaListEl = $("areaList");
const areaEmptyEl = $("areaEmpty");
const hsCountEl = $("hsCount");
const zoomLabelEl = $("zoomLabel");
const btnImportEl = $("btnImport");

/* ===== preview ===== */
const previewPanelEl = $("previewPanel");
const previewImgEl = $("previewImg");
const previewHotspotsEl = $("previewHotspots");
let previewCollapsed = false;

function togglePreviewPanel(){
  previewCollapsed = !previewCollapsed;
  if(previewCollapsed){
    previewPanelEl.classList.add("preview-collapsed");
    $("previewInner").classList.add("hidden");
  }else{
    previewPanelEl.classList.remove("preview-collapsed");
    $("previewInner").classList.remove("hidden");
  }
}

/* ===== helpers ===== */
function normalizeWorkerUrl(raw){
  if(!raw) return "";
  let s = raw.trim();
  if(!/^https?:\/\//i.test(s)) s = "https://" + s;
  return s.replace(/\/+$/,'');
}

function setStatus(msg){
  statusTextEl.textContent = msg;
}

function escapeHtml(str){
  return String(str||"")
    .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
    .replaceAll('"',"&quot;").replaceAll("'","&#039;");
}

async function postJSON(url, data){
  const res = await fetch(url, {
    method:"POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify(data)
  });
  if(!res.ok){
    const t = await res.text().catch(()=> "");
    throw new Error(`HTTP ${res.status}\n${t}`);
  }
  const ct = res.headers.get("content-type") || "";
  return ct.includes("json") ? res.json() : res.text();
}

async function uploadToR2(workerBaseUrl, fileBlob, filename){
  const form = new FormData();
  form.append("file", fileBlob, filename || "image.jpg");
  const res = await fetch(workerBaseUrl + "/upload", { method:"POST", body: form });
  if(!res.ok){
    const t = await res.text().catch(()=> "");
    throw new Error(`HTTP ${res.status}\n${t}`);
  }
  const j = await res.json();
  if(!j.ok || !j.url) throw new Error("ä¸Šå‚³å›å‚³æ ¼å¼ä¸å°");
  return j.url;
}

/* ===== state ===== */
let state = {
  meta: { name: "" },
  triggerKeyword: "",
  imageUrl: "",
  _sourceBlob: null,
  _sourceName: "image",
  frame: { w: FRAME_W, h: FRAME_H },
  mode: "hotspot", // hotspot | crop
  crop: { tx: 0, ty: 0, s: 1 },
  hotspots: [],
  selectedId: null
};

/* ===== history (Undo/Redo) ===== */
let history = [];
let historyIndex = -1;
let wheelCommitTimer = null;

function cloneForHistory(s){
  return JSON.parse(JSON.stringify({
    meta: s.meta,
    triggerKeyword: s.triggerKeyword,
    imageUrl: s.imageUrl,
    frame: s.frame,
    mode: s.mode,
    crop: s.crop,
    hotspots: s.hotspots,
    selectedId: s.selectedId
  }));
}
function pushHistory(){
  const snap = cloneForHistory(state);
  history = history.slice(0, historyIndex + 1);
  history.push(snap);
  historyIndex++;
}
function applyHistorySnap(snap){
  state.meta = snap.meta;
  state.triggerKeyword = snap.triggerKeyword;
  state.imageUrl = snap.imageUrl;
  state.frame = snap.frame;
  state.mode = snap.mode;
  state.crop = snap.crop;
  state.hotspots = snap.hotspots;
  state.selectedId = snap.selectedId;

  triggerEl.value = state.triggerKeyword || "";
  fileNameEl.value = (state.meta?.name || "");
  setMode(state.mode, true);
  setImageUrl(state.imageUrl, true);

  renderAll(true);
}
function undo(){
  if(historyIndex <= 0) return;
  historyIndex--;
  applyHistorySnap(history[historyIndex]);
}
function redo(){
  if(historyIndex >= history.length - 1) return;
  historyIndex++;
  applyHistorySnap(history[historyIndex]);
}

/* ===== view pan/zoom ===== */
let view = { x: 0, y: 0, z: 1 };
function updateStageTransform(){
  stageEl.style.transform = `translate(${view.x}px, ${view.y}px) scale(${view.z})`;
  zoomLabelEl.textContent = Math.round(view.z * 100) + "%";
}
function resetView(){
  view = { x: 0, y: 0, z: 1 };
  updateStageTransform();
}
function zoomBy(factor, anchorClientX=null, anchorClientY=null){
  const oldZ = view.z;
  const newZ = Math.min(4, Math.max(0.15, oldZ * factor));

  if(anchorClientX != null && anchorClientY != null){
    const rect = workspaceEl.getBoundingClientRect();
    const ax = anchorClientX - rect.left;
    const ay = anchorClientY - rect.top;
    const dx = ax - (rect.width/2);
    const dy = ay - (rect.height/2);

    view.x = (view.x - dx) * (newZ/oldZ) + dx;
    view.y = (view.y - dy) * (newZ/oldZ) + dy;
  }

  view.z = newZ;
  updateStageTransform();
}
function fitToScreen(){
  const wr = workspaceEl.getBoundingClientRect();
  const pad = 140;
  const maxW = Math.max(200, wr.width - pad);
  const maxH = Math.max(200, wr.height - pad);
  const z = Math.min(2.5, Math.max(0.08, Math.min(maxW/FRAME_W, maxH/FRAME_H)));
  view = { x: 0, y: 0, z };
  updateStageTransform();
}

/* ===== panel collapse ===== */
let panelCollapsed = false;
function togglePanel(){
  panelCollapsed = !panelCollapsed;
  panelEl.classList.toggle("hidden", panelCollapsed);
}

/* ===== artboard setup ===== */
function setupArtboard(){
  artboardEl.style.width = FRAME_W + "px";
  artboardEl.style.height = FRAME_H + "px";
  renderSafety();
}
function renderSafety(){
  safetyEl.innerHTML = "";
  const m = 36;
  const box = document.createElement("div");
  box.style.position = "absolute";
  box.style.left = m + "px";
  box.style.top = m + "px";
  box.style.right = m + "px";
  box.style.bottom = m + "px";
  box.style.border = "2px dashed rgba(15,23,42,.22)";
  box.style.borderRadius = "12px";
  safetyEl.appendChild(box);
}

/* ===== mode ===== */
function setMode(mode, silent=false){
  state.mode = mode;
  imgLayerEl.classList.toggle("crop", mode === "crop");
  if(!silent) pushHistory();
  setStatus(mode === "crop" ? "è£åˆ‡ä¸­" : "ç•«æ¡†ä¸­");
}

/* ===== image / crop ===== */
function setImageUrl(url, silent=false){
  state.imageUrl = url || "";
  if(state.imageUrl){
    imgEl.src = state.imageUrl;
    previewImgEl.src = state.imageUrl;
  }else{
    imgEl.removeAttribute("src");
    previewImgEl.removeAttribute("src");
  }
  if(!silent) pushHistory();
  refreshPreview();
}

function applyCropTransform(){
  const t = state.crop;
  imgEl.style.transform = `translate(calc(-50% + ${t.tx}px), calc(-50% + ${t.ty}px)) scale(${t.s})`;
}

/* ===== hotspots ===== */
function uid(){
  return "hs_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
}
function selectHotspot(id){
  state.selectedId = id;
  renderHotspots();
  renderHotspotList();
}
function addHotspot(nx, ny, nw, nh){
  const id = uid();
  state.hotspots.push({ id, x:nx, y:ny, w:nw, h:nh, text:"" });
  state.selectedId = id;
  pushHistory();
  renderAll();
}
function deleteSelected(){
  if(!state.selectedId) return;
  const i = state.hotspots.findIndex(h => h.id === state.selectedId);
  if(i >= 0){
    state.hotspots.splice(i,1);
    state.selectedId = null;
    pushHistory();
    renderAll();
  }
}

/* ===== precision: convert mouse to artboard local (æœ€é—œéµï¼šç•«æ¡†æº–) ===== */
function pointInArtboard(clientX, clientY){
  const r = artboardEl.getBoundingClientRect(); // æœƒåŒ…å« pan/zoom å¾Œçš„å¯¦éš›è¢å¹•ä½ç½®
  const px = clientX - r.left;
  const py = clientY - r.top;
  const nx = px / r.width;
  const ny = py / r.height;
  return { px, py, nx, ny, r };
}

/* ===== render ===== */
function renderHotspots(){
  hotspotLayerEl.innerHTML = "";

  state.hotspots.forEach((h, idx) => {
    const d = document.createElement("div");
    d.className = "hotspot" + (h.id === state.selectedId ? " selected" : "");
    d.style.left = (h.x * 100) + "%";
    d.style.top = (h.y * 100) + "%";
    d.style.width = (h.w * 100) + "%";
    d.style.height = (h.h * 100) + "%";
    d.textContent = (idx + 1);

    d.addEventListener("mousedown", (ev) => {
      ev.stopPropagation();
      if(state.mode !== "hotspot") return;
      selectHotspot(h.id);
      beginDragHotspot(ev, h.id, "move");
    });
    d.addEventListener("click", (ev) => {
      ev.stopPropagation();
      selectHotspot(h.id);
    });

    if(h.id === state.selectedId && state.mode === "hotspot"){
      ["nw","ne","sw","se"].forEach(pos=>{
        const hd = document.createElement("div");
        hd.className = "handle " + pos;
        hd.addEventListener("mousedown", (ev)=>{
          ev.stopPropagation();
          beginDragHotspot(ev, h.id, pos);
        });
        d.appendChild(hd);
      });
    }

    hotspotLayerEl.appendChild(d);
  });

  hsCountEl.textContent = state.hotspots.length + " å€‹";
}
function renderHotspotList(){
  areaListEl.innerHTML = "";
  areaEmptyEl.classList.toggle("hidden", state.hotspots.length !== 0);

  state.hotspots.forEach((h, idx) => {
    const row = document.createElement("div");
    row.className = "border rounded-lg p-2 bg-white";
    const selected = (h.id === state.selectedId);

    row.innerHTML = `
      <div class="flex items-center justify-between mb-2">
        <div class="font-bold text-sm ${selected ? 'text-blue-700' : 'text-slate-700'}">æ¡† ${idx+1}</div>
        <div class="flex items-center gap-2">
          <button class="text-xs ${selected ? 'text-blue-700' : 'text-slate-500'} underline">é¸å–</button>
          <button class="text-xs text-red-600 underline">åˆªé™¤</button>
        </div>
      </div>
      <div class="text-xs text-slate-500 mb-1">é»æ­¤æ¡†é€å‡ºæ–‡å­—ï¼š</div>
      <input class="w-full border rounded px-2 py-2 text-sm font-bold"
        placeholder="ä¾‹å¦‚ï¼šMENU_HEALTH / MENU_SHOP / MENU_JOIN"
        value="${escapeHtml(h.text)}">
    `;

    const btnSelect = row.querySelectorAll("button")[0];
    const btnDel = row.querySelectorAll("button")[1];
    const input = row.querySelector("input");

    btnSelect.onclick = () => selectHotspot(h.id);
    btnDel.onclick = () => {
      if(confirm(`åˆªé™¤æ¡† ${idx+1}ï¼Ÿ`)){
        const i = state.hotspots.findIndex(x => x.id === h.id);
        if(i>=0){
          state.hotspots.splice(i,1);
          if(state.selectedId === h.id) state.selectedId = null;
          pushHistory();
          renderAll();
        }
      }
    };
    input.oninput = () => {
      h.text = input.value;
      refreshPreview();
    };
    input.onblur = () => pushHistory();

    areaListEl.appendChild(row);
  });
}
function renderAll(silent=false){
  applyCropTransform();
  renderHotspots();
  renderHotspotList();
  refreshPreview();
  if(!silent) setImportButtonState();
}

/* ===== right preview auto render ===== */
function refreshPreview(){
  previewHotspotsEl.innerHTML = "";
  if(!state.imageUrl) return;

  // é è¦½æ¡†ä¸Šçš„äº’å‹•é»æ“Šï¼ˆæ¨¡æ“¬ï¼‰
  requestAnimationFrame(()=>{
    const r = previewHotspotsEl.getBoundingClientRect();
    if(!r.width || !r.height) return;

    state.hotspots.forEach((h, i)=>{
      // é¡¯ç¤ºæ¡†
      const box = document.createElement("div");
      box.style.position = "absolute";
      box.style.left = (h.x * 100) + "%";
      box.style.top  = (h.y * 100) + "%";
      box.style.width  = (h.w * 100) + "%";
      box.style.height = (h.h * 100) + "%";
      box.style.border = "2px solid rgba(239,68,68,.9)";
      box.style.background = "rgba(239,68,68,.10)";
      box.style.borderRadius = "10px";
      previewHotspotsEl.appendChild(box);

      // é»æ“Šå±¤
      const btn = document.createElement("button");
      btn.style.position = "absolute";
      btn.style.left = (h.x * 100) + "%";
      btn.style.top  = (h.y * 100) + "%";
      btn.style.width  = (h.w * 100) + "%";
      btn.style.height = (h.h * 100) + "%";
      btn.style.background = "transparent";
      btn.onclick = () => {
        alert(`ç†±å€ ${i+1}\nå°‡é€å‡ºï¼š${(h.text||"").trim() || "ï¼ˆå°šæœªå¡«ï¼‰"}`);
      };
      previewHotspotsEl.appendChild(btn);
    });
  });
}

/* ===== draw new hotspot (æº–) ===== */
let drawing = false;
let drawStart = { x:0, y:0 };
let drawRectEl = null;

drawLayerEl.addEventListener("mousedown", (ev)=>{
  if(state.mode !== "hotspot") return;
  if(!state.imageUrl) return alert("è«‹å…ˆåŒ¯å…¥åœ–ç‰‡");
  const p = pointInArtboard(ev.clientX, ev.clientY);

  // å¿…é ˆåœ¨åº•æ¡†å…§æ‰é–‹å§‹
  if(p.nx < 0 || p.nx > 1 || p.ny < 0 || p.ny > 1) return;

  drawing = true;
  drawStart = { x:p.px, y:p.py };

  drawRectEl = document.createElement("div");
  drawRectEl.className = "draw-rect";
  drawRectEl.style.left = drawStart.x + "px";
  drawRectEl.style.top = drawStart.y + "px";
  drawRectEl.style.width = "0px";
  drawRectEl.style.height = "0px";
  drawLayerEl.appendChild(drawRectEl);

  state.selectedId = null;
  renderHotspots();
});

window.addEventListener("mousemove", (ev)=>{
  if(!drawing || !drawRectEl) return;
  const p = pointInArtboard(ev.clientX, ev.clientY);

  // clamp inside
  const cx = Math.min(Math.max(p.px, 0), p.r.width);
  const cy = Math.min(Math.max(p.py, 0), p.r.height);

  const x = Math.min(drawStart.x, cx);
  const y = Math.min(drawStart.y, cy);
  const w = Math.abs(cx - drawStart.x);
  const h = Math.abs(cy - drawStart.y);

  drawRectEl.style.left = x + "px";
  drawRectEl.style.top = y + "px";
  drawRectEl.style.width = w + "px";
  drawRectEl.style.height = h + "px";
});

window.addEventListener("mouseup", ()=>{
  if(!drawing) return;
  drawing = false;

  if(drawRectEl){
    const rect = drawRectEl.getBoundingClientRect();
    drawRectEl.remove();
    drawRectEl = null;

    const ab = artboardEl.getBoundingClientRect();
    const x = rect.left - ab.left;
    const y = rect.top - ab.top;
    const w = rect.width;
    const h = rect.height;

    if(w < 18 || h < 18) return;

    const nx = x / ab.width;
    const ny = y / ab.height;
    const nw = w / ab.width;
    const nh = h / ab.height;

    addHotspot(nx, ny, nw, nh);
  }
});

/* ===== drag/resize hotspot ===== */
let drag = null;
function beginDragHotspot(ev, id, kind){
  const h = state.hotspots.find(x=>x.id===id);
  if(!h) return;

  const ab = artboardEl.getBoundingClientRect();
  drag = {
    id, kind,
    ab,
    startMouse: { x: ev.clientX, y: ev.clientY },
    startBox: { x:h.x, y:h.y, w:h.w, h:h.h }
  };
  window.addEventListener("mousemove", onDragHotspot);
  window.addEventListener("mouseup", endDragHotspot, { once:true });
}
function onDragHotspot(ev){
  if(!drag) return;
  const h = state.hotspots.find(x=>x.id===drag.id);
  if(!h) return;

  const dx = (ev.clientX - drag.startMouse.x) / drag.ab.width;
  const dy = (ev.clientY - drag.startMouse.y) / drag.ab.height;

  let nx = drag.startBox.x;
  let ny = drag.startBox.y;
  let nw = drag.startBox.w;
  let nh = drag.startBox.h;

  const min = 0.02;

  if(drag.kind === "move"){
    nx = drag.startBox.x + dx;
    ny = drag.startBox.y + dy;
  }else{
    if(drag.kind.includes("n")){
      ny = drag.startBox.y + dy;
      nh = drag.startBox.h - dy;
    }
    if(drag.kind.includes("s")){
      nh = drag.startBox.h + dy;
    }
    if(drag.kind.includes("w")){
      nx = drag.startBox.x + dx;
      nw = drag.startBox.w - dx;
    }
    if(drag.kind.includes("e")){
      nw = drag.startBox.w + dx;
    }
  }

  nw = Math.max(min, nw);
  nh = Math.max(min, nh);
  nx = Math.min(1 - nw, Math.max(0, nx));
  ny = Math.min(1 - nh, Math.max(0, ny));

  h.x = nx; h.y = ny; h.w = nw; h.h = nh;

  renderHotspots();
  refreshPreview();
}
function endDragHotspot(){
  window.removeEventListener("mousemove", onDragHotspot);
  drag = null;
  pushHistory();
  renderHotspotList();
}

/* ===== crop drag image ===== */
let cropDrag = null;
imgLayerEl.addEventListener("mousedown", (ev)=>{
  if(state.mode !== "crop") return;
  if(!state.imageUrl) return;

  cropDrag = {
    startMouse: { x: ev.clientX, y: ev.clientY },
    start: { tx: state.crop.tx, ty: state.crop.ty }
  };
  window.addEventListener("mousemove", onCropDrag);
  window.addEventListener("mouseup", endCropDrag, { once:true });
});
function onCropDrag(ev){
  if(!cropDrag) return;
  const dx = ev.clientX - cropDrag.startMouse.x;
  const dy = ev.clientY - cropDrag.startMouse.y;
  state.crop.tx = cropDrag.start.tx + dx;
  state.crop.ty = cropDrag.start.ty + dy;
  applyCropTransform();
}
function endCropDrag(){
  window.removeEventListener("mousemove", onCropDrag);
  cropDrag = null;
  pushHistory();
}

/* ===== workspace pan (space drag) ===== */
let isSpaceDown = false;
let panning = false;
let panStart = { x:0, y:0, vx:0, vy:0 };

workspaceEl.addEventListener("mousedown", (ev)=>{
  if(isSpaceDown && ev.button === 0){
    panning = true;
    panStart = { x: ev.clientX, y: ev.clientY, vx: view.x, vy: view.y };
    window.addEventListener("mousemove", onPanMove);
    window.addEventListener("mouseup", endPan, { once:true });
  }
});
function onPanMove(ev){
  if(!panning) return;
  view.x = panStart.vx + (ev.clientX - panStart.x);
  view.y = panStart.vy + (ev.clientY - panStart.y);
  updateStageTransform();
}
function endPan(){
  window.removeEventListener("mousemove", onPanMove);
  panning = false;
}

/* ===== wheel zoom ===== */
workspaceEl.addEventListener("wheel", (ev)=>{
  // Ctrl+wheel => zoom view
  if(ev.ctrlKey){
    ev.preventDefault();
    const factor = ev.deltaY < 0 ? 1.08 : 1/1.08;
    zoomBy(factor, ev.clientX, ev.clientY);
    return;
  }

  // crop image scale: Alt+wheelï¼ˆæ”¯æ´ undo/redoï¼Œåš debounce commitï¼‰
  if(state.mode === "crop" && ev.altKey){
    ev.preventDefault();
    const factor = ev.deltaY < 0 ? 1.05 : 1/1.05;
    state.crop.s = Math.min(8, Math.max(0.2, state.crop.s * factor));
    applyCropTransform();

    if(wheelCommitTimer) clearTimeout(wheelCommitTimer);
    wheelCommitTimer = setTimeout(()=> pushHistory(), 180);
  }
}, { passive:false });

/* ===== keyboard shortcuts (Ctrl+Z / Ctrl+Y å…¨é€šç”¨) ===== */
window.addEventListener("keydown", (ev)=>{
  if(ev.code === "Space"){
    ev.preventDefault();
    isSpaceDown = true;
  }

  // Undo/Redo
  const key = ev.key.toLowerCase();
  if(ev.ctrlKey && !ev.shiftKey && key === "z"){
    ev.preventDefault(); undo(); return;
  }
  if((ev.ctrlKey && key === "y") || (ev.ctrlKey && ev.shiftKey && key === "z")){
    ev.preventDefault(); redo(); return;
  }

  // Delete
  if(ev.key === "Delete"){
    ev.preventDefault();
    deleteSelected();
  }

  // Esc
  if(ev.key === "Escape"){
    state.selectedId = null;
    renderHotspots();
    renderHotspotList();
  }
});
window.addEventListener("keyup", (ev)=>{
  if(ev.code === "Space") isSpaceDown = false;
});

/* ===== import button state ===== */
function setImportButtonState(){
  if(state.imageUrl){
    btnImportEl.textContent = "å·²åŒ¯å…¥";
    btnImportEl.classList.remove("bg-blue-600","hover:bg-blue-700");
    btnImportEl.classList.add("bg-emerald-600","hover:bg-emerald-700");
  }else{
    btnImportEl.textContent = "åŒ¯å…¥åœ–ç‰‡";
    btnImportEl.classList.remove("bg-emerald-600","hover:bg-emerald-700");
    btnImportEl.classList.add("bg-blue-600","hover:bg-blue-700");
  }
}

/* ===== import/upload ===== */
async function pickAndUpload(){
  const base = normalizeWorkerUrl(workerUrlEl.value || localStorage.getItem("line_worker_url"));
  if(!base) return alert("è«‹å…ˆåœ¨é¦–é è¼¸å…¥ Worker ç¶²å€");
  workerUrlEl.value = base;
  localStorage.setItem("line_worker_url", base);

  const input = $("fileInput");
  input.value = "";
  input.onchange = async (e)=>{
    const file = e.target.files[0];
    if(!file) return;

    try{
      setStatus("åŒ¯å…¥ä¸­...");
      btnImportEl.disabled = true;

      // ç›´æ¥ä¸Šå‚³åŸåœ–ï¼ˆR2ï¼‰ï¼Œå¾ŒçºŒç”¨ã€Œè£åˆ‡ã€èª¿æ•´ï¼Œæœ€å¾Œå†ã€Œè¼¸å‡ºä¸Šå‚³ã€æˆ 2500Ã—1686
      const url = await uploadToR2(base, file, file.name || "image.jpg");

      state._sourceBlob = file;
      state._sourceName = (file.name || "image").replace(/\.[^/.]+$/, "");

      // reset state
      state.imageUrl = url;
      state.crop = { tx:0, ty:0, s:1 };
      state.hotspots = [];
      state.selectedId = null;

      setImageUrl(url, true);
      applyCropTransform();

      pushHistory();
      renderAll();

      setMode("hotspot", true);
      fitToScreen();

      setStatus("å°±ç·’");
    }catch(err){
      setStatus("å¤±æ•—");
      alert("åŒ¯å…¥å¤±æ•—ï¼š\n" + err.message);
    }finally{
      btnImportEl.disabled = false;
      setImportButtonState();
    }
  };
  input.click();
}

/* ===== export crop -> 2500Ã—1686 -> upload -> replace imageUrl (undoable) ===== */
async function exportCropAndUpload(){
  const base = normalizeWorkerUrl(workerUrlEl.value || localStorage.getItem("line_worker_url"));
  if(!base) return alert("è«‹å…ˆåœ¨é¦–é è¼¸å…¥ Worker ç¶²å€");
  if(!state.imageUrl) return alert("è«‹å…ˆåŒ¯å…¥åœ–ç‰‡");
  workerUrlEl.value = base;
  localStorage.setItem("line_worker_url", base);

  try{
    setStatus("è¼¸å‡ºä¸Šå‚³ä¸­...");

    const im = await new Promise((resolve, reject)=>{
      const x = new Image();
      x.crossOrigin = "anonymous";
      x.onload = ()=> resolve(x);
      x.onerror = ()=> reject(new Error("åœ–ç‰‡è¼‰å…¥å¤±æ•—ï¼ˆå¯èƒ½ CORSï¼‰"));
      x.src = state.imageUrl;
    });

    const W = FRAME_W, H = FRAME_H;

    const canvas = document.createElement("canvas");
    canvas.width = W;
    canvas.height = H;
    const ctx = canvas.getContext("2d");

    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0,0,W,H);

    // cover scale
    const sCover = Math.max(W / im.naturalWidth, H / im.naturalHeight);
    const s = sCover * state.crop.s;

    const dw = im.naturalWidth * s;
    const dh = im.naturalHeight * s;

    const cx = W/2 + state.crop.tx;
    const cy = H/2 + state.crop.ty;

    const dx = cx - dw/2;
    const dy = cy - dh/2;

    ctx.drawImage(im, dx, dy, dw, dh);

    const outBlob = await new Promise(res=> canvas.toBlob(res, "image/jpeg", 0.92));
    if(!outBlob) throw new Error("è¼¸å‡ºå¤±æ•—");

    const filename = (state._sourceName || "richmenu") + `_2500x1686.jpg`;
    const url = await uploadToR2(base, outBlob, filename);

    // replace to baked image, reset crop
    state.imageUrl = url;
    state.crop = { tx:0, ty:0, s:1 };
    setImageUrl(url, true);
    applyCropTransform();

    pushHistory();
    renderAll();

    setStatus("å®Œæˆ");
  }catch(err){
    setStatus("å¤±æ•—");
    alert("è¼¸å‡ºä¸Šå‚³å¤±æ•—ï¼š\n" + err.message);
  }
}

/* ===== clear ===== */
function clearAll(){
  if(!confirm("ç¢ºå®šæ¸…ç©ºåœ–ç‰‡ + å…¨éƒ¨ç†±å€ï¼Ÿ")) return;
  state.imageUrl = "";
  state.hotspots = [];
  state.selectedId = null;
  state.crop = { tx:0, ty:0, s:1 };
  imgEl.removeAttribute("src");
  previewImgEl.removeAttribute("src");
  pushHistory();
  renderAll();
  setImportButtonState();
}

/* ===== build imagemap-like payload (ä½ è¦å­˜ KV ç”¨) =====
(é€™è£¡ä¸æ”¹ä½ çš„ worker.jsï¼šé‚„æ˜¯ç”¨ /save keyword+payload)
*/
async function buildMessage(){
  if(!state.imageUrl) throw new Error("å°šæœªåŒ¯å…¥åœ–ç‰‡");
  if(state.hotspots.length === 0) throw new Error("å°šæœªæ–°å¢ç†±å€");
  if(state.hotspots.some(h => !String(h.text||"").trim())) throw new Error("æœ‰ç†±å€æ²’æœ‰å¡«å…§å®¹");

  const baseW = FRAME_W;
  const baseH = FRAME_H;

  // ç”¨ imagemap çš„ area æ ¼å¼ï¼ˆä½  worker.js ç¾åœ¨åƒ messages[] ä¹Ÿèƒ½å­˜ï¼‰
  const actions = state.hotspots.map(h => ({
    type: "message",
    text: h.text.trim(),
    area: {
      x: Math.round(h.x * baseW),
      y: Math.round(h.y * baseH),
      width: Math.round(h.w * baseW),
      height: Math.round(h.h * baseH)
    }
  }));

  return {
    type: "imagemap",
    baseUrl: state.imageUrl,
    altText: state.meta?.name ? String(state.meta.name) : "é¸å–®",
    baseSize: { width: baseW, height: baseH },
    actions
  };
}

/* ===== save/load ===== */
async function saveConfig(){
  const base = normalizeWorkerUrl(workerUrlEl.value || localStorage.getItem("line_worker_url"));
  const keyword = (triggerEl.value || "").trim();
  const name = (fileNameEl.value || "").trim();
  if(!base || !keyword) return alert("è«‹å¡« Worker URL + è§¸ç™¼é—œéµå­—");

  workerUrlEl.value = base;
  localStorage.setItem("line_worker_url", base);

  try{
    state.triggerKeyword = keyword;
    state.meta.name = name;

    const msg = await buildMessage();
    const payload = {
      mode: "imagemap",
      meta: { name: state.meta.name || "" },
      messages: [msg]
    };

    await postJSON(base + "/save", { keyword, payload });

    pushHistory();
    setStatus("å·²å„²å­˜");
    alert("å„²å­˜æˆåŠŸ");
  }catch(e){
    setStatus("å¤±æ•—");
    alert("å„²å­˜å¤±æ•—ï¼š\n" + e.message);
  }
}

async function loadConfig(){
  const base = normalizeWorkerUrl(workerUrlEl.value || localStorage.getItem("line_worker_url"));
  const keyword = (triggerEl.value || "").trim();
  if(!base || !keyword) return alert("è«‹å¡« Worker URL + è§¸ç™¼é—œéµå­—");

  workerUrlEl.value = base;
  localStorage.setItem("line_worker_url", base);

  try{
    const data = await postJSON(base + "/load", { keyword });
    const obj = (typeof data === "string") ? JSON.parse(data) : data;

    if(obj.mode !== "imagemap" || !obj.messages?.[0]) throw new Error("ä¸æ˜¯ imagemap æ ¼å¼");
    const m = obj.messages[0];

    state.meta = obj.meta || { name:"" };
    state.triggerKeyword = keyword;
    state.imageUrl = m.baseUrl || "";
    state.crop = { tx:0, ty:0, s:1 };

    const bw = m.baseSize?.width || FRAME_W;
    const bh = m.baseSize?.height || FRAME_H;

    state.hotspots = (m.actions || []).map(a => ({
      id: uid(),
      x: (a.area?.x || 0) / bw,
      y: (a.area?.y || 0) / bh,
      w: (a.area?.width || 0) / bw,
      h: (a.area?.height || 0) / bh,
      text: a.text || ""
    }));
    state.selectedId = state.hotspots[0]?.id || null;

    fileNameEl.value = (state.meta?.name || "");
    setImageUrl(state.imageUrl, true);

    pushHistory();
    renderAll();
    fitToScreen();
    setImportButtonState();
    setStatus("å·²è®€å–");
  }catch(e){
    setStatus("å¤±æ•—");
    alert("è®€å–å¤±æ•—ï¼š\n" + e.message);
  }
}

/* ===== input sync ===== */
triggerEl.addEventListener("input", ()=> state.triggerKeyword = triggerEl.value.trim());
fileNameEl.addEventListener("input", ()=> {
  state.meta.name = fileNameEl.value;
  // æ–‡å­—æ”¹å‹•ä¹Ÿå¯ undoï¼šç”¨ blur commitï¼ˆé¿å…æ¯å­—ä¸€ç­†ï¼‰
});
fileNameEl.addEventListener("blur", ()=> pushHistory());
triggerEl.addEventListener("blur", ()=> pushHistory());

/* ===== init ===== */
(function init(){
  // worker url from home
  const savedUrl = (localStorage.getItem("line_worker_url") || "").trim();
  if(savedUrl) workerUrlEl.value = savedUrl;

  setupArtboard();
  resetView();
  fitToScreen();
  setMode("hotspot", true);

  // init history
  pushHistory();
  setImportButtonState();
  setStatus("å°±ç·’");
})();
imgEl.addEventListener("load", ()=>{
  applyCropTransform();
  refreshPreview();
});
</script>

</body>
</html>
